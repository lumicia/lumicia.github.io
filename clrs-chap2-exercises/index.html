<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>算法导论 Chap2 习题 - lumicia</title><meta name=description content="lumicia"><meta property="og:title" content="算法导论 Chap2 习题"><meta property="og:description" content="2.1 2.1-1 略。 2.1-2 1 2 3 4 5 6 7 for j = 2 to A.length key = A[j] i = j - 1 while i > 0 and A[i] < key A[i + 1] = A[i] i = i - 1 A[i + 1] = key 修改成 A[i] < key 即可。 2.1-3 1 2 3 4 for i = 1 to A.length if"><meta property="og:type" content="article"><meta property="og:url" content="https://lumicia.github.io/clrs-chap2-exercises/"><meta property="og:image" content="https://lumicia.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-02T14:52:05+08:00"><meta property="article:modified_time" content="2021-12-07T13:01:40+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lumicia.github.io/logo.png"><meta name=twitter:title content="算法导论 Chap2 习题"><meta name=twitter:description content="2.1 2.1-1 略。 2.1-2 1 2 3 4 5 6 7 for j = 2 to A.length key = A[j] i = j - 1 while i > 0 and A[i] < key A[i + 1] = A[i] i = i - 1 A[i + 1] = key 修改成 A[i] < key 即可。 2.1-3 1 2 3 4 for i = 1 to A.length if"><meta name=application-name content="lumicia"><meta name=apple-mobile-web-app-title content="lumicia"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://lumicia.github.io/clrs-chap2-exercises/><link rel=prev href=https://lumicia.github.io/clrs-chap2/><link rel=next href=https://lumicia.github.io/clrs-chap3/><link rel=stylesheet href=/css/page.min.css><link rel=stylesheet href=/css/home.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"算法导论 Chap2 习题","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/lumicia.github.io\/clrs-chap2-exercises\/"},"image":[{"@type":"ImageObject","url":"https:\/\/lumicia.github.io\/images\/avatar.webp","width":512,"height":512}],"genre":"posts","keywords":"CLRS","wordcount":3650,"url":"https:\/\/lumicia.github.io\/clrs-chap2-exercises\/","datePublished":"2021-04-02T14:52:05+08:00","dateModified":"2021-12-07T13:01:40+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"lumicia","logo":{"@type":"ImageObject","url":"https:\/\/lumicia.github.io\/images\/avatar.webp","width":512,"height":512}},"author":{"@type":"Person","name":"lumicia"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=lumicia>lumicia</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa fa-archive'></i> 归档 </a><a class=menu-item href=/tags/><i class='fa fa-tags'></i> 标签 </a><a class=menu-item href=/categories/><i class='fa fa-folder-open'></i> 分类 </a><a class=menu-item href=/categories/documentation/><i class='fa fa-book'></i> 文档 </a><a class=menu-item href=/about/><i class='fa fa-user'></i> 关于 </a><a class=menu-item href=https://github.com/lumicia title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a class=menu-item href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=lumicia>lumicia</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class='fa fa-archive'></i>归档</a><a class=menu-item href=/tags/ title><i class='fa fa-tags'></i>标签</a><a class=menu-item href=/categories/ title><i class='fa fa-folder-open'></i>分类</a><a class=menu-item href=/categories/documentation/ title><i class='fa fa-book'></i>文档</a><a class=menu-item href=/about/ title><i class='fa fa-user'></i>关于</a><a class=menu-item href=https://github.com/lumicia title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i></a><div class=menu-item><a href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i></a>
<span>&nbsp;|&nbsp;</span><a href=javascript:void(0); class=theme-switch title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single" data-toc=enable><div class=single-card><h2 class="single-title animated flipInX">算法导论 Chap2 习题</h2><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lumicia title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lumicia</a></span>&nbsp;<span class=post-category>出版于 <a href=/categories/algorithm/><i class="far fa-folder fa-fw"></i>Algorithm</a></span></div><div class=post-meta-line><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-04-02>2021-04-02</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3650 字</span>&nbsp;
<span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟</span>&nbsp;</div></div><hr><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#21>2.1</a><ul><li><a href=#21-1>2.1-1</a></li><li><a href=#21-2>2.1-2</a></li><li><a href=#21-3>2.1-3</a></li><li><a href=#21-4>2.1-4</a></li></ul></li><li><a href=#22>2.2</a><ul><li><a href=#22-1>2.2-1</a></li><li><a href=#22-2>2.2-2</a></li><li><a href=#22-3>2.2-3</a></li><li><a href=#22-4>2.2-4</a></li></ul></li><li><a href=#23>2.3</a><ul><li><a href=#23-1>2.3-1</a></li><li><a href=#23-2>2.3-2</a></li><li><a href=#23-3>2.3-3</a></li><li><a href=#23-4>2.3-4</a></li><li><a href=#23-5>2.3-5</a></li><li><a href=#23-6>2.3-6</a></li><li><a href=#23-7-star>2.3-7 $\star$</a></li></ul></li><li><a href=#思考题>思考题</a><ul><li><a href=#2-1>2-1</a></li><li><a href=#2-2>2-2</a></li><li><a href=#2-3>2-3</a></li><li><a href=#2-4>2-4</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=21>2.1</h2><h3 id=21-1>2.1-1</h3><p>略。</p><h3 id=21-2>2.1-2</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for j = 2 to A.length
</span></span><span class=line><span class=cl>	key = A[j]
</span></span><span class=line><span class=cl>	i = j - 1
</span></span><span class=line><span class=cl>	while i &gt; 0 and A[i] &lt; key
</span></span><span class=line><span class=cl>		A[i + 1] = A[i]
</span></span><span class=line><span class=cl>		i = i - 1
</span></span><span class=line><span class=cl>	A[i + 1] = key
</span></span></code></pre></td></tr></table></div></div><p>修改成 <code>A[i] &lt; key</code> 即可。</p><h3 id=21-3>2.1-3</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for i = 1 to A.length
</span></span><span class=line><span class=cl>	if A[i] == v
</span></span><span class=line><span class=cl>		return i
</span></span><span class=line><span class=cl>return NIL
</span></span></code></pre></td></tr></table></div></div><p>循环不变式：每次 $for$ 循环开始迭代时，子数组 $A[1..i-1]$ 由均不等于 $v$ 的元素组成。</p><p>初始化：证明循环不变式在循环开始前为真。循环开始前 $i=1$。子数组为空，因此为真。</p><p>保持：证明循环不变式在循环的下一次迭代时仍为真。将 $A[i]$ 和 $v$ 相比较，如果二者相同，就返回 $i$；否则循环继续下一次迭代。每次循环的迭代结束时，子数组 $A[1..i]$ 中不包含 $v$，因此循环不变式仍为真。在循环下一次迭代中递增 $i$ 的值将维持循环不变式。</p><p>终止：证明循环不变式在循环终止时仍为真。让循环结束的条件为 $i>A.length=n$，确切地说此时必定有 $i=n+1$。将 $i$ 替换为 $n+1$，则子数组 $A[1..n]$ 由均不等于 $v$ 的元素组成，因此返回 $\text{NIL}$。观察到子数组 $A[1..n]$ 等于原来的整个数组，可以得出结论原数组中不包含等于 $v$ 的元素。故算法正确。</p><h3 id=21-4>2.1-4</h3><p>因为涉及到进位，需要考虑如何计算相加后 $C$ 中的数字。使用一个变量来保存 $A$ 和 $B$ 每个位相加时的进位。使用模运算可以得到相加后的余数，使用除法求进位的数字。</p><p>举个例子： $A = [1, 0, 0, 1]$，$B = [1, 1, 0, 1]$，则 $C = [1, 0, 1, 1, 0]$。</p><p>形式化描述：</p><p>输入: $A$ 和 $B$ 都是二进制数字的数组，长度均为 $n$​。</p><p>$\forall i\in{1\dots n}:\ A[i],B[i]\in{0,1}$.</p><p>输出: 二进制数字的数组 $C$，长度为 $n+1$。</p><p>$\forall i\in{1\dots n+1}:\ C[i]\in{0,1}$:
$$
\sum_{i=1}^{n+1}C[i]*2^{i-1}=\sum_{j=1}^{n}A[j]*2^{j-1}+\sum_{k=1}^{n}B[k]*2^{k-1}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let C[A.length + 1] be new array
</span></span><span class=line><span class=cl>carry = 0
</span></span><span class=line><span class=cl>for i = A.length downto 1
</span></span><span class=line><span class=cl>	// remainder
</span></span><span class=line><span class=cl>	C[i + 1] = (A[i] + B[i] + carry) % 2
</span></span><span class=line><span class=cl>	// quotient
</span></span><span class=line><span class=cl>	carry = (A[i] + B[i] + carry) / 2
</span></span><span class=line><span class=cl>C[1] = carry
</span></span><span class=line><span class=cl>return C
</span></span></code></pre></td></tr></table></div></div><h2 id=22>2.2</h2><h3 id=22-1>2.2-1</h3><p>$\Theta(n^3)$。</p><h3 id=22-2>2.2-2</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for i = 1 to A.length - 1
</span></span><span class=line><span class=cl>	min = A[i]
</span></span><span class=line><span class=cl>	for j = i + 1 to A.length
</span></span><span class=line><span class=cl>		if A[i] &gt; A[j]
</span></span><span class=line><span class=cl>			min = A[j]
</span></span><span class=line><span class=cl>	swap(A[i], min)
</span></span></code></pre></td></tr></table></div></div><p>1、循环不变式：在 $for$ 循环的开始，子数组 $A[1..i-1]$ 由数组 $A$ 中已排序的最小的 $i-1$ 个元素组成。</p><p>初始化：循环开始前 $i=1$，子数组为空，因此为真。</p><p>保持：循环每次迭代结束时，将最小值放到 $A[i]$ 的位置，子数组 $A[1..i-1]$ 中的元素都比 $A[i]$ 小，且已排序，因此循环不变式为真。在循环下一次迭代中递增 $i$ 的值将维持循环不变式。</p><p>终止：循环结束的条件为 $i=A.length=n$。此时子数组 $A[1..n-1]$ 由原来数组 $A[1..n]$ 的 $n-1$ 个元素组成，且已排序。而剩下的元素则保证不小于子数组中的元素，因此整个数组都是有序的。故算法正确。</p><p>2、前 $n-1$ 个元素排序完成后，子数组 $A[1..n-1]$ 由数组 $A$ 中已排序的最小的 $n-1$ 个元素组成，因此第 $n$ 个元素必定是数组中最大的元素，此时它已经在正确的位置，无需再排序。</p><p>3、选择排序最好的情况（数组已排序）和最坏的情况（数组逆序）都需要将外循环和内循环的每一条语句执行一遍，所以都需要 $\Theta(n^2)$ 时间。</p><h3 id=22-3>2.2-3</h3><p>1、分析在数组 $A[a_1,a_2,\dots,a_n]$ 中进行线性查找的平均情况：第 1 个元素需要查找 1 个元素，第 2 个元素查找 2 个，以此类推，第 n 个元素查找 n 个。总共查找 n 次，因此平均个数为 $\cfrac{1+2+\dots+n}n=\cfrac{n+1}2$ 个。</p><p>2、最坏情况是查找到第 $n$ 个元素。</p><p>3、平均情况和最坏情况的运行时间都是 $\Theta(n)$。</p><h3 id=22-4>2.2-4</h3><p>没看懂问题，看了下官方的答案，应该是通过添加一个特殊的情况，如果输入符合这个特例，则输出预先计算的结果，这样就可以得到最好情况的运行时间了。</p><h2 id=23>2.3</h2><h3 id=23-1>2.3-1</h3><p>略。</p><h3 id=23-2>2.3-2</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>n1 = q - p + 1
</span></span><span class=line><span class=cl>n2 = r - q
</span></span><span class=line><span class=cl>let L[1..n1] and R[1..n2] be new arrays
</span></span><span class=line><span class=cl>for i = 1 to n1
</span></span><span class=line><span class=cl>	L[i] = A[p + i - 1]
</span></span><span class=line><span class=cl>for j = 1 to n2
</span></span><span class=line><span class=cl>	R[j] = A[q + j]
</span></span><span class=line><span class=cl>i = 1
</span></span><span class=line><span class=cl>j = 1
</span></span><span class=line><span class=cl>k = p
</span></span><span class=line><span class=cl>while i &lt; n1 and j &lt; n2
</span></span><span class=line><span class=cl>    if L[i] &lt; R[j]
</span></span><span class=line><span class=cl>        A[k] = L[i]
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>        A[k] = R[j]
</span></span><span class=line><span class=cl>        j = j + 1
</span></span><span class=line><span class=cl>    k = k + 1
</span></span><span class=line><span class=cl>if j == n2
</span></span><span class=line><span class=cl>    A[k..r] = L[i..n1]
</span></span></code></pre></td></tr></table></div></div><p>第 19 行只需要判断 <code>j</code> 是否等于右子数组的长度，因为左子数组的长度是大于等于右子数组的。如果右子数组已遍历完，则表示左子数组中剩余的元素都大于循环开始时右子数组的任意元素，并且已排序。此时只需要将左子数组中的剩余元素复制到合并数组中即可。</p><h3 id=23-3>2.3-3</h3><p>以下用 $\lg n$ 表示 $\log_2 n$。</p><p>基本情况：当 $n=2$ 时，$T(n)=2 \lg 2 = 2$。</p><p>设 $n=2^k$，$T(n)=n\lg n=2^k\lg 2^k=2^k\cdot k$。</p><p>对于 $n=2^{k+1}$，</p><div>$$
\begin{aligned}
T(n) & = 2 \cdot T(2^{k + 1}/2)+2^{k + 1} \\
& = 2 \cdot T(2^k) + 2^{k + 1} \\
& = 2 \cdot 2^k + 2^{k + 1} \\
& = 2^{k + 1}\cdot (k + 1) \\
& = 2^{k + 1}\cdot \lg 2^{k + 1} \\
& = n\lg n.
\end{aligned}
$$</div><p>故 $T(n)=n\lg n$，其中 $n$ 是 2 的整数幂。</p><h3 id=23-4>2.3-4</h3><p>最坏情况下将 $A[n]$ 插入到已排序数组 $A[1..n - 1]$ 需要的时间为 $\Theta(n)$，因此：</p><div>$$
T(n) =
\begin{cases}
\Theta(1) &\ \text{if}\ n = 1, \\
T(n - 1) + \Theta(n) &\ \text{if}\ n>1.
\end{cases}
$$</div>递推式的结果是 $\Theta(n^2)$。<p>递归式插入排序的关键操作是「合并」步骤中将 $A[n]$ 插入到已排序数组 $A[1..n - 1]$ 中。这一过程用辅助函数 <code>insert(A, n)</code> 表示。</p><p>只要向排序主函数 <code>insertion_sort_recursive(A, n)</code> 传递的数组 $A$ 长度大于 0 ，就可以递归调用它自身，然后调用 <code>insert(A, n)</code> 合并。</p><h3 id=23-5>2.3-5</h3><p>迭代式：<code>ITERATIVE-BINARY-SEARCH(A, v, lo, hi)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>while lo &lt;= hi
</span></span><span class=line><span class=cl>    mid = floor((lo + hi) / 2)
</span></span><span class=line><span class=cl>    if A[mid] == v
</span></span><span class=line><span class=cl>        return mid
</span></span><span class=line><span class=cl>    else if A[mid] 
</span></span><span class=line><span class=cl>        lo = mid + 1
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>        hi = mid - 1
</span></span><span class=line><span class=cl>return NIL
</span></span></code></pre></td></tr></table></div></div><p>递归式：<code>RECURSIVE-BINARY-SEARCH(A, v, lo, hi)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if lo &gt; hi
</span></span><span class=line><span class=cl>    return NIL
</span></span><span class=line><span class=cl>mid = floor((lo + hi) / 2)
</span></span><span class=line><span class=cl>if A[mid] == v
</span></span><span class=line><span class=cl>    return mid
</span></span><span class=line><span class=cl>else if A[mid] &lt; v
</span></span><span class=line><span class=cl>    return RECURSIVE-BINARY-SEARCH(A, v, mi + 1, hi)
</span></span><span class=line><span class=cl>else return RECURSIVE-BINARY-SEARCH(A, v, lo, mid - 1)
</span></span></code></pre></td></tr></table></div></div><p>算法每次都将 $v$ 和数组中点元素相比较，从而将搜索范围减半。</p><p>递归式：</p><div>$$
T(n) =
\begin{cases}
\Theta (1) & \text{if}\ n = 1, \\
T(n/2)+\Theta (1) & \text{if}\ n > 1.
\end{cases}
$$</div>递归式的结果是 $\Theta(\lg n)$。<h3 id=23-6>2.3-6</h3><p>不能。查找虽然是 $\Theta(\lg n)$，但移动元素仍然是 $\Theta(n)$。</p><h3 id=23-7-star>2.3-7 $\star$</h3><p>首先对 $S$ 排序，需要 $\Theta(n\lg n)$ 时间。</p><p>然后对于 $S$ 中的元素 $e_i$，$i = 1,\dots,n$，用二分查找在 $A[i + 1..n]$ 中查找 $e_j = x - e_i$，需要 $\Theta(\lg n)$ 时间。</p><p>如果找到 $e_j$，返回 $j$ 的值；否则进行下一次迭代。</p><p>算法总共所需时间 $\Theta(n\lg n) + n\cdot \Theta(\lg n)=\Theta(n\lg n)$。</p><h2 id=思考题>思考题</h2><h3 id=2-1>2-1</h3><p>a. 对长度为 $k$ 的子表使用插入排序的最坏情况需要 $\Theta(k^2)$ 时间，因此对 $n / k$ 个长度为 $k$ 的子表使用插入排序的最坏情况需要 $n / k \cdot \Theta(k^2) = \Theta(nk)$ 时间。</p><p>b. 因为有 $n / k$ 个子表，每次将两个子表合并，需要合并的次数是 $\lg (n / k)$；每次合并最坏时间为 $\Theta(n)$，所以将所有子表合并的最坏情况是 $\Theta(n \lg (n / k))$。</p><p>c. 根据题意有 $\Theta (nk + n \lg (n / k)) \leqslant \Theta(n \lg n)$。因此 $nk$ 对整体时间的影响应该小于 $ n\lg n$，$k$ 的最大值为 $\lg n$。</p><p>d. 选择让插入排序比归并排序快时的 $k$ 的值。</p><h3 id=2-2>2-2</h3><p>a. $A&rsquo;$ 中的元素都是 $A$ 中的元素，不过已排序。</p><p>b. 循环不变式：第 2-4 行的 <code>for</code> 循环每次迭代开始时，子数组 $A[j..n]$ 由原来在 $A[j..n]$ 中的元素组成，但顺序可能发生了变化，且首元素 $A[j]$ 是子数组中最小的元素。</p><p>初始化：循环第一次迭代开始时，子数组仅包含单个元素 $A[n]$，因此是有序的。</p><p>保持 ：每次迭代都将 $A[j]$ 和 $A[j - 1]$ 比较，并让较小的元素交换到下标较小的位置。迭代完成后，子数组 $A[j..n]$ 递增一个元素，且首元素是子数组中最小的元素。</p><p>终止：导致 $for$ 循环终止的条件是 $j = i$。在循环不变式中用 $i$ 代替 $j$，有：子数组 $A[i..n]$ 由原来在 $A[i..n]$ 中的元素组成，$A[i]$ 是子数组中最小的元素。</p><p>c. 循环不变式：第 1-4 行的 $for$ 循环每次迭代开始时，子数组 $A[1..i - 1]$ 由数组 $A[1..n]$ 中最小的 $i - 1$ 个元素组成，且已排序。子数组 $A[i..n]$ 由 $A[1..n]$ 中剩余的元素组成。</p><p>初始化：循环第一次迭代开始时，子数组 $A[1..i - 1]$ 是空数组。</p><p>保持：内循环每次迭代后，$A[i]$ 都会成为子数组 $A[i..n]$ 中最小的元素。在下次外循环开始前，$A[1..i - 1]$ 由比 $A[i..n]$ 中更小的元素组成，且已排序。外循环迭代后，$A[1..i]$ 将包含比 $A[i + 1..n]$ 更小的元素，且已排序。</p><p>终止：当 $i = A.length$ 时，循环终止。此时 $A[1..n]$ 将由所有已排序的元素组成。</p><p>d. 第 $i$ 次外循环将执行 $n - i$ 次内循环，所以最坏情况运行时间是 $\Theta(n^2)$。理论上运行时间和插入排序一样，但由于多次交换操作，实际会更慢。</p><h3 id=2-3>2-3</h3><p>a. $\Theta(n)$。</p><p>b. <code>NAIVE-POLYNOMIAL-EVALUATION</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>y = 0
</span></span><span class=line><span class=cl>for i = 0 to n
</span></span><span class=line><span class=cl>    m = 1
</span></span><span class=line><span class=cl>    for k = 1 to i
</span></span><span class=line><span class=cl>        m = m * x
</span></span><span class=line><span class=cl>    y = y + a[i] * m
</span></span></code></pre></td></tr></table></div></div><p>运行时间是 $\Theta(n^2)$，比 Horner 规则慢许多。</p><p>c. 初始化：一开始没有项，$y = 0$。</p><p>保持：在第 $i$ 次迭代，有</p><div>$$
\begin{aligned}
y & = a_i + x \sum_{k = 0}^{n - (i + 1)} a_{k + i + 1} x^k \\
& = a_i x^0 + \sum_{k = 0}^{n - i - 1} a_{k + i + 1} x^{k + 1} \\
& = a_i x^0 + \sum_{k = 1}^{n - i} a_{k + i} x^k \\
& = \sum_{k = 0}^{n - i} a_{k + i} x^k.
\end{aligned}
$$</div><p>终止：当 $i = -1$ 时终止，将 $i = 0$ 代入，得 $\displaystyle y = \sum_{k = 0}^{n - i - 1} a_{k + i + 1} x^k = \sum_{k = 0}^n a_k x^k$。</p><p>d. 在 c 中证明了循环不变式，循环不变式的和等于给定系数的多项式。</p><h3 id=2-4>2-4</h3><p>a. $(1, 5)$，$(2, 5)$，$(3, 4)$，$(3, 5)$，$(4, 5)$。</p><p>b. 集合 ${1, 2, \ldots, n}$ 的逆序构成的数组 $\langle n, n - 1, \cdots, 1\rangle$ 具有最多的逆序对。逆序对的个数为 $(n - 1) + (n - 2) + \cdots + 1 = \cfrac{n(n - 1)}{2}$。</p><p>c. 插入排序的运行时间正比于逆序对的数量。</p><p>d. 首先需要清楚逆序对的构成。如果对数组进行归并排序来计算逆序对，则数组的逆序对由子数组中的逆序对和跨子数组的逆序对两部分组成。实际只要计算跨子数组的逆序对，因为子数组中的逆序对可以通过递归计算它自己的两部分逆序对得到。</p><p><code>CROSS-INVERSION-COUNT(A, p, q, r)</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>n1 = q - p + 1
</span></span><span class=line><span class=cl>n2 = r - q
</span></span><span class=line><span class=cl>let L[1..n1 + 1] and R[1..n2 + 1] be new arrays
</span></span><span class=line><span class=cl>    for i = 1 to n1
</span></span><span class=line><span class=cl>L[i] = A[p + i - 1]
</span></span><span class=line><span class=cl>    for j = 1 to n2
</span></span><span class=line><span class=cl>R[j] = A[q + j]
</span></span><span class=line><span class=cl>L[n1 + 1] = ∞
</span></span><span class=line><span class=cl>R[n2 + 1] = ∞
</span></span><span class=line><span class=cl>i = 1
</span></span><span class=line><span class=cl>j = 1
</span></span><span class=line><span class=cl>inversions = 0
</span></span><span class=line><span class=cl>for k = p to r
</span></span><span class=line><span class=cl>    if L[i] &lt;= R[j]
</span></span><span class=line><span class=cl>        A[k] = L[i]
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>        inversions = inversions + n1 - i + 1
</span></span><span class=line><span class=cl>        A[k] = R[j]
</span></span><span class=line><span class=cl>        j = j + 1
</span></span><span class=line><span class=cl>return inversions
</span></span></code></pre></td></tr></table></div></div><p><code>INVERSIONS-COUNT(A, p, r)</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if p &lt; r
</span></span><span class=line><span class=cl>    q = floor((p + r) / 2)
</span></span><span class=line><span class=cl>    left = INVERSION-COUNT(A, p, q)
</span></span><span class=line><span class=cl>    right = INVERSION-COUNT(A, q + 1, r)
</span></span><span class=line><span class=cl>    inversions = CROSS-INVERSION-COUNT(A, p, q, r) + left + right
</span></span><span class=line><span class=cl>    return inversions
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-tag><span><a href=/tags/clrs/>CLRS</a></span></div><div class=post-info-line><div class=post-info-mod><span>更新于 2021-12-07&nbsp;<a class=git-hash href=https://github.com/lumicia/lumicia/github.io/commit/b25413cdda335ee3b50dfaaad0f728bf5d9e28e3 target=_blank title="committed&nbsp;by&nbsp;lumicia(arxzs1057@gmail.com)&nbsp;b25413c:&nbsp;Add CLRS Chap4">
<i class="fas fa-hashtag fa-fw"></i>b25413c</a></span></div><div class=post-info-mod><span><a class=link-to-markdown href=/clrs-chap2-exercises/index.md target=_blank>阅读原始文档</a></span></div></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://lumicia.github.io/clrs-chap2-exercises/ data-title="算法导论 Chap2 习题" data-via=xxxx data-hashtags=CLRS><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://lumicia.github.io/clrs-chap2-exercises/ data-hashtag=CLRS><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://lumicia.github.io/clrs-chap2-exercises/ data-title="算法导论 Chap2 习题"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://lumicia.github.io/clrs-chap2-exercises/ data-title="算法导论 Chap2 习题"><i class="fab fa-line fa-fw"></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://lumicia.github.io/clrs-chap2-exercises/ data-title="算法导论 Chap2 习题"><i class="fab fa-weibo fa-fw"></i></a></span></div></div><div class=post-nav><a href=/clrs-chap2/ class=prev rel=prev title="算法导论 Chap2：算法基础"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
<a href=/clrs-chap3/ class=next rel=next title="算法导论 Chap3：函数的增长">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div></div><div id=comments class=single-card></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.105.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/khusika/FeelIt target=_blank rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lumicia>lumicia</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><script>"serviceWorker"in navigator&&(navigator.serviceWorker.register("/sw.min.js?version=1.0.1",{scope:"/"}).then(()=>{console.info("lumicia\u00A0Service Worker Registered")},e=>console.error("lumicia\u00A0Service Worker registration failed: ",e)),navigator.serviceWorker.ready.then(()=>{console.info("lumicia\u00A0Service Worker Ready")}))</script></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-chevron-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment-alt fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/copy-tex.min.css><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.0/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.10.3/dist/algoliasearch-lite.umd.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.1/sharer.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/copy-tex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/mhchem.min.js></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"UAL0NNJWXE",algoliaIndex:"index.zh-cn",algoliaSearchKey:"7b7fbdfb7ee82ee61901f2c6b09b05be",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script src=/js/theme.min.js></script></body></html>