<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lumicia</title><link>https://lumicia.github.io/</link><description>lumicia</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>zuoshengxie@outlook.com (lumicia)</managingEditor><webMaster>zuoshengxie@outlook.com (lumicia)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 22 Apr 2021 13:10:05 +0800</lastBuildDate><atom:link href="https://lumicia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>算法导论 Chap6 习题</title><link>https://lumicia.github.io/clrs-chap6-exercises/</link><pubDate>Thu, 22 Apr 2021 13:10:05 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap6-exercises/</guid><description>6.1 6.1-1 每层都完全填满的二叉堆第 $i$ 层元素个数是 $2^{i - 1}$。 由几何级数公式 $A.5$，高度为 $h$ 的堆中元素个数最多为 $\displaystyle \sum_{i = 1}^{h + 1} 2^{i - 1} = \cfrac{2^{h + 1} - 1}{2 -</description></item><item><title>算法导论 Chap8：线性时间排序</title><link>https://lumicia.github.io/clrs-chap8/</link><pubDate>Tue, 20 Apr 2021 12:05:19 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap8/</guid><description>如果排序算法的最终结果中，各元素的次序依赖于它们之间的比较，则把这种排序算法称为比较排序。我们对比较排序算法需要比较的最少次数感兴趣，即算法</description></item><item><title>算法导论 Chap6：堆、堆排序和优先级队列</title><link>https://lumicia.github.io/clrs-chap6/</link><pubDate>Fri, 16 Apr 2021 09:53:52 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap6/</guid><description>堆是一个数组，可用近似完全二叉树1表示。表示堆的数组的两个属性： 数组长度； 堆大小。 堆大小表示数组中实际存储在堆中的数据。堆大小不小于 $0$，</description></item><item><title>算法导论 Chap5：概率分析和随机算法</title><link>https://lumicia.github.io/clrs-chap5/</link><pubDate>Thu, 15 Apr 2021 13:32:42 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap5/</guid><description>本章讨论了当算法的运行时间不是算法重点时的分析方法。以雇用问题举例，每次对候选的应聘者进行比较，只要比上一位应聘者要好，就立即雇用，直到最后</description></item><item><title>算法导论 Chap4：分治策略</title><link>https://lumicia.github.io/clrs-chap4/</link><pubDate>Sat, 10 Apr 2021 09:48:50 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap4/</guid><description>分治策略 分治策略的三个步骤： 分解：分解原问题为形式相同但规模更小的子问题； 解决：递归求解子问题，对规模足够小的子问题直接求解； 合并：合并子问</description></item><item><title>算法导论 Chap3 习题</title><link>https://lumicia.github.io/clrs-chap3-exercises/</link><pubDate>Wed, 07 Apr 2021 09:33:29 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap3-exercises/</guid><description>3.1 3.1-1 因为 $f(n)$ 和 $g(n)$ 都是渐近非负的，所以对于 $f(n)$ 和 $g(n)$ 有： $$ \begin{aligned} \exists n_1:\quad f(n) &amp; \geqslant 0\quad \text{for all}\ n > n_1 \\ \exists n_2:\quad g(n) &amp; \geqslant 0\quad \text{for all}\ n > n_2 \end{aligned} $$ 令 $n_0 = \max(n_1, n_2)$，则对于 $n &amp;gt; n_0$</description></item><item><title>算法导论 Chap3：函数的增长</title><link>https://lumicia.github.io/clrs-chap3/</link><pubDate>Sat, 03 Apr 2021 11:35:36 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap3/</guid><description>渐近记号 当算法的输入规模足够大时，运行时间与增长量级密切相关。此时，需要通过渐近分析来研究输入规模趋近无限时，算法的运行时间如何随输入规模的</description></item><item><title>算法导论 Chap2 习题</title><link>https://lumicia.github.io/clrs-chap2-exercises/</link><pubDate>Fri, 02 Apr 2021 14:52:05 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap2-exercises/</guid><description>2.1 2.1-1 略。 2.1-2 1 2 3 4 5 6 7 for j = 2 to A.length key = A[j] i = j - 1 while i &amp;gt; 0 and A[i] &amp;lt; key A[i + 1] = A[i] i = i - 1 A[i + 1] = key 修改成 A[i] &amp;lt; key 即可。 2.1-3 1 2 3 4 for i = 1 to A.length if</description></item><item><title>算法导论 Chap2：算法基础</title><link>https://lumicia.github.io/clrs-chap2/</link><pubDate>Fri, 26 Mar 2021 09:00:25 +0800</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/clrs-chap2/</guid><description>循环不变式 当我们写完程序后，通常会编写测试来检查程序是否产生预期的结果。如果结果和预期一致，则认为程序能正常完成任务。但是有限的测试用例无法</description></item><item><title/><link>https://lumicia.github.io/arch--wsl2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>zuoshengxie@outlook.com (lumicia)</author><guid>https://lumicia.github.io/arch--wsl2/</guid><description>Arch + WSL2 下载 arch.zip：https://github.com/yuk7/ArchWSL/releases。 解压，执行 Arch.exe： 1</description></item></channel></rss>