<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>算法导论 Chap4：分治策略 - lumicia</title><meta name=description content="lumicia"><meta property="og:title" content="算法导论 Chap4：分治策略"><meta property="og:description" content="分治策略 分治策略的三个步骤： 分解：分解原问题为形式相同但规模更小的子问题； 解决：递归求解子问题，对规模足够小的子问题直接求解； 合并：合并子问"><meta property="og:type" content="article"><meta property="og:url" content="https://lumicia.github.io/clrs-chap4/"><meta property="og:image" content="https://lumicia.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-10T09:48:50+08:00"><meta property="article:modified_time" content="2022-02-13T11:38:00+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lumicia.github.io/logo.png"><meta name=twitter:title content="算法导论 Chap4：分治策略"><meta name=twitter:description content="分治策略 分治策略的三个步骤： 分解：分解原问题为形式相同但规模更小的子问题； 解决：递归求解子问题，对规模足够小的子问题直接求解； 合并：合并子问"><meta name=application-name content="lumicia"><meta name=apple-mobile-web-app-title content="lumicia"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://lumicia.github.io/clrs-chap4/><link rel=prev href=https://lumicia.github.io/clrs-chap3-exercises/><link rel=next href=https://lumicia.github.io/clrs-chap5/><link rel=stylesheet href=/css/page.min.css><link rel=stylesheet href=/css/home.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"算法导论 Chap4：分治策略","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/lumicia.github.io\/clrs-chap4\/"},"image":[{"@type":"ImageObject","url":"https:\/\/lumicia.github.io\/images\/avatar.webp","width":512,"height":512}],"genre":"posts","keywords":"CLRS, Python","wordcount":2122,"url":"https:\/\/lumicia.github.io\/clrs-chap4\/","datePublished":"2021-04-10T09:48:50+08:00","dateModified":"2022-02-13T11:38:00+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"lumicia","logo":{"@type":"ImageObject","url":"https:\/\/lumicia.github.io\/images\/avatar.webp","width":512,"height":512}},"author":{"@type":"Person","name":"lumicia"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=lumicia>lumicia</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa fa-archive'></i> 归档 </a><a class=menu-item href=/tags/><i class='fa fa-tags'></i> 标签 </a><a class=menu-item href=/categories/><i class='fa fa-folder-open'></i> 分类 </a><a class=menu-item href=/categories/documentation/><i class='fa fa-book'></i> 文档 </a><a class=menu-item href=/about/><i class='fa fa-user'></i> 关于 </a><a class=menu-item href=https://github.com/lumicia title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a class=menu-item href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i> </a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=lumicia>lumicia</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class='fa fa-archive'></i>归档</a><a class=menu-item href=/tags/ title><i class='fa fa-tags'></i>标签</a><a class=menu-item href=/categories/ title><i class='fa fa-folder-open'></i>分类</a><a class=menu-item href=/categories/documentation/ title><i class='fa fa-book'></i>文档</a><a class=menu-item href=/about/ title><i class='fa fa-user'></i>关于</a><a class=menu-item href=https://github.com/lumicia title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw'></i></a><div class=menu-item><a href=/index.xml title=RSS><i class="fas fa-rss fa-fw" title=RSS></i></a>
<span>&nbsp;|&nbsp;</span><a href=javascript:void(0); class=theme-switch title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single" data-toc=enable><div class=single-card><h2 class="single-title animated flipInX">算法导论 Chap4：分治策略</h2><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lumicia title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lumicia</a></span>&nbsp;<span class=post-category>出版于 <a href=/categories/algorithm/><i class="far fa-folder fa-fw"></i>Algorithm</a></span></div><div class=post-meta-line><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-04-10>2021-04-10</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2122 字</span>&nbsp;
<span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟</span>&nbsp;</div></div><hr><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#分治策略>分治策略</a></li><li><a href=#最大子数组问题>最大子数组问题</a></li><li><a href=#用代入法求解递归式>用代入法求解递归式</a></li><li><a href=#用递归树方法求解递归式>用递归树方法求解递归式</a></li><li><a href=#用主方法求解递归式>用主方法求解递归式</a></li></ul></nav></div></div><div class=content id=content><h2 id=分治策略>分治策略</h2><p>分治策略的三个步骤：</p><ul><li>分解：分解原问题为形式相同但规模更小的子问题；</li><li>解决：递归求解子问题，对规模足够小的子问题直接求解；</li><li>合并：合并子问题的解，得到原问题的解。</li></ul><p>子问题的两种情况：</p><ul><li>递归情况：当子问题足够大，需要递归求解的情况；</li><li>基本情况：子问题变得足够小，不再需要递归求解的情况。</li></ul><p>对于与原问题形式不同的子问题的求解视为合并步骤的一部分。</p><p>递归式是一个等式或不等式，通过更小的输入上的函数值来描述一个函数。</p><p>例 1 归并排序的递归式：</p><div>$$
T(n) =
\begin{cases}
\Theta(1) & 若\ n = 1, \\
2T(n / 2) + \Theta(n) & 若\ n > 1.
\end{cases}
$$</div>递归求解可得 $T(n) = \Theta(n\lg n)$。<p>例 2 规模不等的子问题。如将子问题划分为 $\cfrac{2}{3}$ 和 $\cfrac{1}{3}$，假设分解和合并步骤都是线性时间的，则得到的递归式：
$$
T(n) = T(2n / 3) + T(n / 3) = \Theta(n)
$$
例 3 递归的线性查找。线性查找的递归版本仅生成一个子问题，其规模仅比原问题的规模少一个元素。每次递归调用将花费常量时间加上下一层递归调用的时间。因此递归式为：
$$
T(n) = T(n - 1) + \Theta(1) = \Theta(n)
$$
获取递归式的 $\Theta$ 或 $O$ 渐近界的三种求解方式：</p><ul><li>代入法（substitution method）首先猜测一个界，然后用数学归纳法证明。</li><li>递归树法（recursion-tree method）将递归式转换成一棵树，以结点表示不同层次递归产生的代价。然后用界之和（bounding summation）的技术求解递归式。</li><li>主方法（master method）求解 $T(n) = aT(n / b) + f(n)$ 形式的递归式的界，其中 $a \geqslant 1$，$b > 1$，$f(n)$ 是给定的函数。分治算法将原问题分为 $a$ 个子问题，每个子问题都是原问题规模的 $\cfrac{1}{b}$，分解与合并步骤总共需要 $f(n)$ 时间。</li></ul><p>当递归式是不等式时，可以用 $O$ 或 $\Omega$ 来描述递归式的解。</p><p>当声明和求解递归式时，通常忽略向上、下取整和边界条件这些对结果影响不大的细节。</p><h2 id=最大子数组问题>最大子数组问题</h2><p>最大子数组问题要寻找一个数组的最大子数组。</p><p>最大子数组的定义：一个数组的非空子数组，该子数组的元素之和是所有子数组中最大的。</p><p>一个数组可能有多个最大子数组。</p><p>只有数组中包含负数时，最大子数组问题才有意义。</p><p>寻找最大子数组可以采用分治策略，效仿第二章的思考题 2-4 寻找逆序对，它一定在数组 $A$ 的左半边，或右半边，或跨越数组中点。前两种情况可以递归求解，因为这两个子问题也是相同形式的最大子数组问题，只是规模更小。因此主要处理的是寻找跨越数组中点的最大子数组的情况，然后在三种情况中选取最大的那个子数组，即为 $A$ 的最大子数组。</p><p>对于跨越子数组 $A[low..high]$ 中点的最大子数组，由中点左边部分的子数组 $A[i..mid]$ 和右边部分的子数组 $A[mid+1..j]$ 组成。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_max_crossing_subarray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>low</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>mid</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>high</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=n>left_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>sum</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>mid</span><span class=p>,</span> <span class=n>low</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>sum</span> <span class=o>=</span> <span class=nb>sum</span> <span class=o>+</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>sum</span> <span class=o>&gt;</span> <span class=n>left_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left_sum</span> <span class=o>=</span> <span class=nb>sum</span>
</span></span><span class=line><span class=cl>            <span class=n>max_left</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>right_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sum2</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>sum2</span> <span class=o>=</span> <span class=n>sum2</span> <span class=o>+</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>sum2</span> <span class=o>&gt;</span> <span class=n>right_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right_sum</span> <span class=o>=</span> <span class=n>sum2</span>
</span></span><span class=line><span class=cl>            <span class=n>max_right</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>max_left</span><span class=p>,</span> <span class=n>max_right</span><span class=p>,</span> <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>find_max_crossing_subarray</code> 所需时间为 $\Theta(n)$。</p><p>我们现在能够对最大子数组的三种情况进行处理了，接下来就可以定义寻找最大子数组的函数 <code>find_maximum_subarray</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_maximum_subarray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>low</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>high</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>high</span> <span class=o>==</span> <span class=n>low</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=n>left_low</span><span class=p>,</span> <span class=n>left_high</span><span class=p>,</span> <span class=n>left_sum</span> <span class=o>=</span> <span class=n>find_maximum_subarray</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>right_low</span><span class=p>,</span> <span class=n>right_high</span><span class=p>,</span> <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find_maximum_subarray</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cross_low</span><span class=p>,</span> <span class=n>cross_high</span><span class=p>,</span> <span class=n>cross_sum</span> <span class=o>=</span> <span class=n>find_max_crossing_subarray</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left_sum</span> <span class=o>&gt;=</span> <span class=n>right_sum</span> <span class=ow>and</span> <span class=n>left_sum</span> <span class=o>&gt;=</span> <span class=n>cross_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>left_low</span><span class=p>,</span> <span class=n>left_high</span><span class=p>,</span> <span class=n>left_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>right_sum</span> <span class=o>&gt;=</span> <span class=n>left_sum</span> <span class=ow>and</span> <span class=n>right_sum</span> <span class=o>&gt;=</span> <span class=n>cross_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>right_low</span><span class=p>,</span> <span class=n>right_high</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>cross_low</span><span class=p>,</span> <span class=n>cross_high</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>最后定义一个快捷地对整个数组寻找最大子数组的函数 <code>maximum_subarray</code>，便于测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>maximum_subarray</span><span class=p>(</span><span class=n>a</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=nb>int</span> <span class=o>|</span> <span class=nb>float</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>find_maximum_subarray</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>第 2 节矩阵乘法的 Strassen 算法跳过。</p></blockquote><h2 id=用代入法求解递归式>用代入法求解递归式</h2><p>代入法的两个步骤：</p><ul><li>猜测解的形式。</li><li>用数学归纳法求出解中的常数，并证明解是正确的。</li></ul><h2 id=用递归树方法求解递归式>用递归树方法求解递归式</h2><p>在递归树中，每个结点表示单个子问题的代价，子问题对应某次递归函数的调用。将树中每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到所有层次的递归调用的总代价。</p><p>递归树可以用来生成好的猜测，然后用代入法来验证猜测是否正确。</p><h2 id=用主方法求解递归式>用主方法求解递归式</h2><p>主方法用于求解形如 $T(n) = aT(n / b) + f(n)$ 的递归式。其中 $a \geqslant 1$ 和 $b > 1$ 且为常量，$f(n)$ 是渐近正函数。$a$ 表示将规模为 $n$ 分解后的子问题的个数，$b$ 表示每个子问题的规模是原问题的 $n / b$，$f(n)$ 表示问题分解和子问题的解合并所需的代价。</p><blockquote><p>主定理：令 $a \geqslant 1$ 和 $b > 1$ 为常量，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式：
$$
T(n) = aT(\frac{n}{b}) + f(n)
$$
其中 $\cfrac{n}{b}$ 意为 $\lfloor \cfrac{n}{b} \rfloor$ 或 $\lceil \cfrac{n}{b} \rceil$。则 $T(n)$ 具有如下渐近界：</p><ol><li>若对某个常数 $\epsilon > 0$ 有 $f(n) = O(n^{\log_b{a - \epsilon}})$，则 $T(n) = \Theta(n^{\log_b{a}})$。</li><li>若 $f(n) = \Theta(n^{\log_b{a}})$，则 $T(n) = \Theta(n^{\log_b{a}} \lg n)$。</li><li>若对某个常数 $\epsilon > 0$ 有渐近正函数 $f(n) = \Omega(n^{\log_b{a + \epsilon}})$，且对某个常量 $c &lt; 1$ 和所有足够大的 $n$ 有 $af(\cfrac{n}{b}) \leqslant cf(n)$，则 $T(n) = \Theta(f(n))$。</li></ol></blockquote><p>通过比较函数 $f(n)$ 与函数 $n^{\log_b{a}}$ 的大小来匹配三种情况之一。较大者决定递归式的解。$n^{\log_b{a}}$ 更大有情况 1，$f(n)$ 更大有情况 3，大小相等则有情况 2。这里的大小比较是多项式意义上的比较。</p><p>三种情况未完全覆盖 $f(n)$ 的所有可能性。1 和 2 与 2 和 3 之间分别可能存在间隙。只有保证间隙也在多项式意义上大小关系一致，才能使用主定理。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-tag><span><a href=/tags/clrs/>CLRS</a>
</span><span><a href=/tags/python/>Python</a></span></div><div class=post-info-line><div class=post-info-mod><span>更新于 2022-02-13&nbsp;<a class=git-hash href=https://github.com/lumicia/lumicia/github.io/commit/ae966bd159095121890d7dedd99f701d3bd9bd1c target=_blank title="committed&nbsp;by&nbsp;lumicia(arxzs1057@gmail.com)&nbsp;ae966bd:&nbsp;update CLRS chap8">
<i class="fas fa-hashtag fa-fw"></i>ae966bd</a></span></div><div class=post-info-mod><span><a class=link-to-markdown href=/clrs-chap4/index.md target=_blank>阅读原始文档</a></span></div></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://lumicia.github.io/clrs-chap4/ data-title="算法导论 Chap4：分治策略" data-via=xxxx data-hashtags=CLRS,Python><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://lumicia.github.io/clrs-chap4/ data-hashtag=CLRS><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://lumicia.github.io/clrs-chap4/ data-title="算法导论 Chap4：分治策略"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://lumicia.github.io/clrs-chap4/ data-title="算法导论 Chap4：分治策略"><i class="fab fa-line fa-fw"></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://lumicia.github.io/clrs-chap4/ data-title="算法导论 Chap4：分治策略"><i class="fab fa-weibo fa-fw"></i></a></span></div></div><div class=post-nav><a href=/clrs-chap3-exercises/ class=prev rel=prev title="算法导论 Chap3 习题"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
<a href=/clrs-chap5/ class=next rel=next title="算法导论 Chap5：概率分析和随机算法">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div></div><div id=comments class=single-card></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.105.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/khusika/FeelIt target=_blank rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lumicia>lumicia</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><script>"serviceWorker"in navigator&&(navigator.serviceWorker.register("/sw.min.js?version=1.0.1",{scope:"/"}).then(()=>{console.info("lumicia\u00A0Service Worker Registered")},e=>console.error("lumicia\u00A0Service Worker registration failed: ",e)),navigator.serviceWorker.ready.then(()=>{console.info("lumicia\u00A0Service Worker Ready")}))</script></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-chevron-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment-alt fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/copy-tex.min.css><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.0/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.10.3/dist/algoliasearch-lite.umd.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.1/sharer.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/copy-tex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/mhchem.min.js></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"UAL0NNJWXE",algoliaIndex:"index.zh-cn",algoliaSearchKey:"7b7fbdfb7ee82ee61901f2c6b09b05be",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script src=/js/theme.min.js></script></body></html>