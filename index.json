[{"categories":["Algorithm"],"content":"6.1 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-1 每层都完全填满的二叉堆第 $i$ 层元素个数是 $2^{i - 1}$。 由几何级数公式 $A.5$，高度为 $h$ 的堆中元素个数最多为 $\\displaystyle \\sum_{i = 1}^{h + 1} 2^{i - 1} = \\cfrac{2^{h + 1} - 1}{2 - 1} = 2^{h + 1} - 1$，最少为 $1 + \\displaystyle \\sum_{i = 1}^h 2^{i - 1} = 1 + \\cfrac{2^h - 1}{2 - 1} = 2^h$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-2 设该堆的高度为 $h$，由 6.1-1 有 $2^h \\leqslant n \\leqslant 2^{h + 1} - 1$。 两边取对数得 $\\lg(n + 1) - 1 \\leqslant h \\leqslant \\lg n$。 故高度为 $\\lfloor \\lg n \\rfloor$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-3 假设该子树中存在一个非根结点的最大元素，则它一定大于它的父结点，这违背了最大堆性质，因此这样的结点不存在。故子树中最大元素一定位于根结点。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-4 假如最小元素所在结点有子结点，则违背最大堆性质，因此最小元素一定位于叶结点。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:4","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-5 对于一个已排序的数组 $A$ 中的元素 $A[i]$，一定有 $A[\\text{PARENT}(i)] \\leqslant A[i]$，其中 $i \u003e 1$，满足最小堆性质，所以 $A$ 是最小堆。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:5","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-6 不是。$A[9] = 7$ 的父结点 $A[\\text{PARENT}(9)] = 6$，不满足最大堆性质。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:6","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.1-7 对于下标为 $\\lfloor n / 2 \\rfloor + 1$ 的结点，假设它有左子结点，则左子结点下标为： $$ \\begin{aligned} \\text{LEFT}(\\lfloor n / 2 \\rfloor + 1) \u0026 = 2(\\lfloor n / 2 \\rfloor + 1) \\\\ \u0026 \u003e 2(n / 2 + 1) - 2 \\\\ \u0026 = n + 2 - 2 \\\\ \u0026 = n \\end{aligned} $$ 因为下标为 $n$ 的结点一定是堆的最后一个结点，而它的左子结点下标大于 $n$，所以不存在。故下标为 $\\lfloor n / 2 \\rfloor + 1$ 的结点是叶结点。从而下标大于 $\\lfloor n / 2 \\rfloor + 1$ 的结点也都是叶结点。 接着证明它是第一个叶结点。考察它的前一个结点，即下标为 $\\lfloor n / 2 \\rfloor$ 的结点。同理可推出当 $n$ 为偶数时，该结点的左子结点下标是 $n$；$n$ 为奇数时，该结点的右子结点下标是 $n$，也就是说该结点是堆中最后一个叶结点的父结点，因此该结点不是叶结点。从而下标 $\\lfloor n / 2 \\rfloor + 1$ 是堆的第一个叶结点。 堆的叶结点总数为 $n - (\\lfloor n / 2 \\rfloor + 1) + 1 = \\lceil n / 2 \\rceil$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:1:7","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-1 略。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-2 MIN-HEAPIFY(A, i)： l = LEFT(i) r = RIGHT(i) if l \u003c= A.heap_size and A[l] \u003c A[i] smallest = l else smallest = i if r \u003c= A.heap_size and A[r] \u003c A[smallest] smallest = r if smallest != r exchange A[i] with A[smallest] MIN-HEAPIFY(A, smallest) 运行时间和 MAX-HEAPIFY 相同，也是 $O(\\lg n)$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-3 没有影响，函数直接返回。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-4 此时，该结点是叶结点，因此没有影响，函数直接返回。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:4","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-5 MAX-HEAPIFY-ITERATIVE(A, i)： while true l = LEFT(i) r = RIGHT(i) if l \u003c= A.heap_size and A[l] \u003e A[i] largest = l else largest = i if r \u003c= A.heap_size and A[r] \u003e A[largest] largest = r if largest == i return exchange A[i] with A[largest] i = largest ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:5","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.2-6 最坏情况是从根结点一直递归到叶结点，因为堆的高度为 $\\lfloor \\lg n \\rfloor$，所以最坏情况运行时间为 $\\Omega(\\lg n)$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:2:6","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.3 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:3:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.3-1 略。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:3:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.3-2 如果从下标 1 开始，子树不一定能维持最大堆性质，MAX-HEAPIFY 调用可能失败。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:3:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.3-3 用数学归纳法来证明。 基本情况：证明高度 $h=0$ 时命题为真。 当 $h = 0$ 时，等价于证明最多有 $\\lceil \\cfrac{n}{2^{h + 1}} \\rceil$ 个叶结点。由 6.1-7 知道所有叶结点下标，可算出叶结点总数为 $n\\ - (\\lfloor \\cfrac{n}{2} \\rfloor + 1) + 1 = n - \\lfloor \\cfrac{n}{2} \\rfloor = \\lceil \\cfrac{n}{2} \\rceil$。 归纳情况：当高度为 $h-1$ 时命题成立，证明对高度为 $h$ 时仍然成立。 设树 $T$ 在高度为 $h$ 的结点个数 $n_h$，叶结点个数 $n_0$。$T$ 删除所有叶结点得到的子树 $T’$。 $T’$ 的所有结点个数 $n’ = n - n_0$。从基本情况有 $n_0 = \\lceil \\cfrac{n}{2} \\rceil$，因此 $n’ = n - \\lceil \\cfrac{n}{2} \\rceil = \\lfloor \\cfrac{n}{2} \\rfloor$。 $T$ 中高度为 $h$ 的结点在 $T’$ 中高度为 $h-1$，设其数量为 $n’{h - 1}$。则 $n_h = n’{h - 1}$。 因为对 $n’{h - 1}$ 命题 $n’{h - 1} \\leqslant \\lceil \\cfrac{n’}{2^h} \\rceil$ 成立，所以： $$ \\begin{aligned} n_h \u0026 = n'_{h - 1} \\\\ \u0026 \\leqslant \\left \\lceil \\frac{n'}{2^h} \\right \\rceil \\\\ \u0026 = \\left \\lceil \\frac{\\lfloor \\frac{n}{2} \\rfloor}{2^h} \\right \\rceil \\\\ \u0026 \\leqslant \\left \\lceil \\frac{\\frac{n}{2}}{2^h} \\right \\rceil \\\\ \u0026 = \\left \\lceil \\frac{n}{2^{h + 1}} \\right \\rceil \\end{aligned} $$ 所以命题对 $h$ 也成立，故原命题成立。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:3:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4-1 略。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4-2 初始化：子数组 $A[i+1..n]$ 为空，因此不变式正确。 保持：$A[1]$ 在 $A[1..i]$ 中最大，并且小于 $A[i+1..n]$ 中的元素。当把 $A[1]$ 放到第 $i$ 个位置，则 $A[i..n]$ 已经是排好序的。递减 heap_size 并调用 MAX-HEAPIFY 会将 $A[1..i-1]$ 变成最大堆。递减 $i$ 的值为下次迭代建立不变式。 终止：在循环结束时，$i = 1$。此时 $A[2..n]$ 是排好序的并且 $A[1]$ 是数组中最小的元素，这让整个数组 $A[1..n]$ 也是排好序的。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4-3 两种情况都是 $\\Theta(n \\lg n)$。 如果数组以升序排序，将数组转化成堆需要 $O(n)$ 时间。然后需要 $ n- 1$ 次调用过程 MAX-HEAPIFY，每次都执行 $\\lg k$ 次操作。因此 $$ \\sum_{k = 1}^{n - 1} \\lg k = \\lg((n - 1)!) = \\Theta(n \\lg n) $$ 降序同理。BUILD-MAX-HEAP 更快（常数因子），但整个计算时间由循环中的 HEAPSORT 主导，因此： $$ \\sum^n_{i = 1} \\lg i = \\lg n! = \\Theta(n \\lg n) $$ ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4-4 当数组已经排好序时，需要线性时间将它转化成最大堆，然后需要 $n \\lg n$ 时间来排序。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:4","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.4-5 $\\star$ 参考：https://stackoverflow.com/questions/4589988/lower-bound-on-heapsort。 The formal lower-bound proof is due to Schaffer and Sedgewick’s\"The Analysis of Heapsort\"paper. Here’s a slightly paraphrased version of the proof that omits some of the technical details. To begin, let’s suppose that $n = 2^k - 1$ for some $k$, which guarantees that we have a complete binary heap. I’ll show how to handle this case separately later on. Because we have $2^k - 1$ elements, the first pass of heapsort will, in $\\Theta(n)$, build up a heap of height $k$. Now, consider the first half of the dequeues from this heap, which removes $2^{k-1}$ nodes from the heap. The first key observation is that if you take the starting heap and then mark all of the nodes here that actually end up getting dequeued, they form a subtree of the heap (i.e. every node that get dequeued has a parent that also gets dequeued). You can see this because if this weren’t the case, then there would be some node whose (larger) parent didn’t get dequeued though the node itself was dequeued, meaning that the values are out of order. Now, consider how the nodes of this tree are distributed across the heap. If you label the levels of the heap $0, 1, 2, \\cdots, k - 1$, then there will be some number of these nodes in levels $0, 1, 2, \\cdots, k - 2$ (that is, everything except the bottom level of the tree). In order for these nodes to get dequeued from the heap, then they have to get swapped up to the root, and they only get swapped up one level at a time. This means that one way to lower-bound the runtime of heapsort would be to count the number of swaps necessary to bring all of these values up to the root. In fact, that’s exactly what we’re going to do. The first question we need to answer is - how many of the largest $2^{k - 1}$ nodes are not in the bottom level of the heap? We can show that this is no greater than $2^{k - 2}$ by contradiction. Suppose that there are at least $2^{k - 2} + 1$ of the largest nodes in the bottom level of the heap. Then each of the parents of those nodes must also be large nodes in level $k - 2$. Even in the best case, this means that there must be at least $2^{k - 3} + 1$ large nodes in level $k - 2$, which then means that there would be at least $2^{k - 4} + 1$ large nodes in level $k - 3$, etc. Summing up over all of these nodes, we get that there are $2^{k - 2} + 2^{k - 3} + 2^{k - 4} + \\cdots + 2^0 + k$ large nodes. But this value is strictly greater than $2^{k - 1}$, contradicting the fact that we’re working with only $2^{k - 1}$ nodes here. Okay… we now know that there are at most $2^{k - 2}$ large nodes in the bottom layer. This means that there must be at least $2^{k - 2}$ of the large nodes in the first $k - 2$ layers. We now ask - what is the sum, over all of these nodes, of the distance from that node to the root? Well, if we have $2^{k - 2}$ nodes positioned somewhere in a complete heap, then at most $2^{k - 3}$ of them can be in the first $k - 3$ levels, and so there are at least $2^{k - 2} - 2^{k - 3} = 2^{k - 3}$ heavy nodes in level $k - 2$. Consequently, the total number of swaps that need to be performed are at least $(k - 2) 2^{k-3}$. Since $n = 2^k-1$, $k = \\Theta(\\lg n)$, and so this value is $\\Theta(n \\lg n)$ as required. ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:4:5","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-1 略。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-2 略。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-3 HEAP-MINIMUM(A)： return A[1] HEAP-EXTRACT-MIN(A)： if A.heap_size \u003c 1 error \"heap underflow\" min = A[1] A[1] = A[A.heap_size] A.heap_size = A.heap_size - 1 MIN-HEAPIFY(A, 1) return min HEAP-DECREASE-KEY(A, i, key)： if key \u003e A[i] error \"new key is larger than current key\" A[i] = key while i \u003e 1 and A[PARENT(i)] \u003e A[i] exchange A[i] with A[PARENT] i = PARENT(i) MIN-HEAP-INSER(A, key)： A.heap_size = A.heap_size + 1 A[A.heap_size] = Infinity HEAP-DECRASE-KEY(A, A.heap_size, key) ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-4 为了维持 HEAP-INCREASE-KEY 过程的 if 语句的条件为真。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:4","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-5 初始化：A[1..heap-size] 满足最大堆性质，除非 $A[i]$ 大于 $A[PARENT(i)]$，因为 $A[i]$ 被修改了。$A[i]$ 大于它的子结点，否则 if 语句会失败，不会进入 while 循环。 保持：在循环中交换 $A[i]$ 和 $A[PARENT(i)]$，满足了最大堆性质。然后在循环下次迭代继续和父结点的父结点比较，继续进行交换，以继续维持最大堆性质。 终止：当堆中元素遍历完，或 $A[i]$ 小于父结点时（维持了最大堆性质），结束循环。此时，$A$ 是最大堆。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:5","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-6 HEAP-INCREASE-KEY(A, i, key)： if key \u003c A[i] error \"new key is smaller than current key\" while i \u003e 1 and A[PARENT(I)] \u003c key A[i] = A[PARENT(i)] i = PARENT(i) A[i] = key ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:6","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-7 对于队列，优先级队列每次插入新元素时递减所添加元素的优先级。 对于栈，优先级队列则以递增优先级的方式添加元素。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:7","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-8 HEAP-DELETE(A, i)： if A[i] \u003e A[A.heap-size] A[i] = A[A.heap-size] MAX-HEAPIFY(A, i) else HEAP-INCREASE-KEY(A, i, A[A.heap-size]) A.heap-size = A.heap-size - 1 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:8","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6.5-9 从 $k$ 个有序链表中分别从头取一个元素，然后放到一个最小堆实现的最小优先级队列中。 合并时，从最小堆中取出最小的元素，插入该元素对应链表中的下一个元素到最小堆中。如果链表为空，则从最小堆中取出倒数第二小的元素，以此类推。持续这个过程，直到最小堆为空，表示已经完成合并。 算法总共需要 $n$ 步将 $n$ 个元素插入到最小优先级队列中，并且每次插入需要 $\\lg k$ 时间，因此算法的时间复杂度是 $O(n \\lg k)$。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:5:9","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"思考题 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:6:0","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6-1 a. 不是相同的。最大堆对于结点的左右子结点的顺序没有要求。对于数组 [1, 2, 3, 4, 5]，自底向上地遍历数组元素构建最大堆得到 [5, 4, 3, 1, 2]，而自顶向下地插入数组元素构建最大堆得到 [5, 4, 2, 1 ,3]。 b. 每次插入最多需要 $O(\\lg n)$ 时间，总共有 $n - 1$ 个元素要插入，时间复杂度为 $(n - 1) \\cdot O(\\lg n) = O(n \\lg n)$。因此插入法在效率方面不如自底向上的 Floyd 建堆算法。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:6:1","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6-2 a. 效仿二叉堆，给定 $d$ 叉堆中一个结点的下标 $i$，计算出它的父结点和子结点的下标。堆的第一个结点下标是 $1$，它的子结点下标是 $1 + 1,1 + 2,\\cdots,1 + d = 2,3,\\cdots,1 + d$。第二个结点的第一个子结点下标是 $(1 + d) + 1$，第二个是 $(1 + d) + 2$，$\\cdots$，第 $d$ 个是 $(1 + d) + d$。第三个结点的第一个子结点下标是 $(1 + 2d) + 1$，第二个是 $(1 + 2d) + 2$，$\\cdots$，第 $d$ 个是 $(1 + 2d) + d$。以此类推，可以归纳出下标为 $i$ 的结点的第 $j$ 个子结点下标是 $1 + (i - 1)d +j$。反过来可以推出父结点下标是 $\\cfrac{i - 1 - j}{d} + 1$，此时可以设 $j = 1$，则父结点下标为 $\\lfloor \\cfrac{i - 2}{d} + 1 \\rfloor$。 D-ARY-PARENT(i)： return floor((i - 2) / d + 1) D-ARY-CHILD(i, j)： return (i - 1)d + j + 1 b. 高度是 $\\Theta(\\log_d n)$。 c. D-ARY-EXTRACT-MAX(A)： if A.heap_size \u003c 1 error \"heap underflow\" max = A[1] A[1] = A[A.heap_size] A.heap_size = A.heap_size - 1 D-ARY-MAX-HEAPIFY(A, 1) return max D-ARY-MAX-HEAPIFY(A, i)： largest = i for j = 1 to d if D-ARY-CHILD(j, i) \u003c= A.heap_size and A[D-ARY-CHILD(j, i)] \u003e A[i] if A[D-ARY-CHILD(j, i)] \u003e largest largest = A[D-ARY-CHILD(j, i)] if largest != i exchange A[i] with A[largest] D-ARY-MAX-HEAPIFY(A, largest) D-ARY-MAX-HEAPIFY 的时间复杂度和结点的高度有关，等于 $O(d \\log_{d}n)$。D-ARY-EXTRACT-MAX 除了调用 D-ARY-MAX-HEAPIFY 以外的操作都是常数项的，因此时间复杂度是 $O(d \\log_{d}n)$。 d. D-ARY-HEAP-INSERT(A, key)： A.heap_size = A.heap_size + 1 A[A.heap_size] = key i = A.heap_size whild i \u003e 1 and A[D-ARY-PARENT] \u003c A[i] exchange A[i] with A[D-ARY-PARENT] i = D-ARY-PARENT(i) 时间复杂度是 $O(\\log_{d}n)$，因为 while 循环运行次数最多和堆高相同。 e. D-ARY-HEAP-INCREASE-KEY(A, i, key)： if key \u003c A[i] error \"new key is smaller than current key\" A[i] = key while i \u003e 1 and A[D-ARY-PARENT] \u003c A[i] exchange A[i] with A[D-ARY-PARENT] i = D-ARY-PARENT(i) 时间复杂度是 $O(\\log_{d}n)$，因为 while 循环运行次数最多和堆高相同。 ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:6:2","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":["Algorithm"],"content":"6-3 TODO ","date":"2021-04-22","objectID":"/clrs-chap6-exercises/:6:3","tags":["CLRS"],"title":"算法导论 Chap6 习题","uri":"/clrs-chap6-exercises/"},{"categories":null,"content":"如果排序算法的最终结果中，各元素的次序依赖于它们之间的比较，则把这种排序算法称为比较排序。我们对比较排序算法需要比较的最少次数感兴趣，即算法的下界。 为方便起见，我们对算法的输入序列 $\u003ca_1, a_2, \\cdots, a_n\u003e$ 做出两个假设： 所有输入的元素互异。 元素比较只采用 $a_i \\leqslant a_j$ 的形式。其中 $1 \\leqslant i$，$j \\leqslant n$。 我们把比较排序抽象为一棵决策树。决策树是一棵满二叉树（full binary tree，中文版在此处有错误）。在满二叉树中，除了叶结点以外的结点都有两个子结点。决策树可用表示在给定输入规模下，某一特定排序算法对所有元素的比较操作。 决策树中的内部结点用 $i:j$ 标注，表示一次比较 $a_i \\leqslant a_j$ ；叶结点用序列元素的一个随机排列标注，表示 $n!$ 中排列中的一种。排序算法的执行对应于一条从根结点到叶结点的路径。如果 $a_i \\leqslant a_j$ 则前往左子树，否则前往右子树。当到达一个叶结点时，排序算法确定序列的顺序。在正确的排序算法中，每个叶结点都可以通过从根结点开始的某条路径到达，该路径就是算法的一次实际执行过程。 当比较排序算法出现最坏情况时所需的比较次数，就是在决策树中从根结点到任意可达叶结点最长简单路径的长度，即决策树的高度。当决策树中每种排列的叶结点都是可达的，决策树高度的下界就是比较排序算法运行时间的下界。 定理：在最坏情况下，任何比较排序算法都需要 $\\Omega(n \\lg n)$ 次比较。 推论：堆排序和归并排序都渐近最优的比较排序算法。 接下来介绍三种使用运算而非比较的排序算法，它们都有线性时间的复杂度。 ","date":"2021-04-20","objectID":"/clrs-chap8/:0:0","tags":null,"title":"算法导论 Chap8：线性时间排序","uri":"/clrs-chap8/"},{"categories":null,"content":"计数排序 计数排序假设 $n$ 个输入元素都是处于 $0$ 到 $k$ 之间的整数。其中 $k$ 是一个整数，当 $k = O(n)$ 时，计数排序的运行时间为 $\\Theta(n)$。 计数排序的基本思想是对每个输入元素 $x$，确定小于 $x$ 的元素个数，从而把 $x$ 放到输出数组中的正确位置。 count_sort： def count_sort(a: list[int], b: list[int], k: int): c = [0] * (k + 1) for j in a: c[j] += 1 for i in range(1, k + 1): c[i] += c[i - 1] for j in a[::-1]: b[c[j] - 1] = j c[j] -= 1 函数参数 a 表示输入数组，b 表示输出数组。变量 c 是辅助数组，下标从 $0$ 开始，长度为 $k + 1$。这样就可以用 c 的下标表示 $0$ 到 $k$ 的整数。 c 的所有元素都初始化为 $0$，然后第一个 for 循环对 a 中元素计数，循环结束后 c 中的数组元素表示 a 中每个整数出现的次数。第二个 for 循环计数所有小于等于 i 的元素个数。第三个 for 循环将 a 中所有元素放在 b 中正确排序后的位置。 计数排序是稳定排序，具有相同值的元素在输入和输出数组中的相对次序不变。 ","date":"2021-04-20","objectID":"/clrs-chap8/:1:0","tags":null,"title":"算法导论 Chap8：线性时间排序","uri":"/clrs-chap8/"},{"categories":null,"content":"基数排序 基数排序利用一种稳定排序在线性时间内对最大 $d$ 位整数数组排序。 步骤如下： 取得最大数，以它的数位作为基准，给其他数位较短的数的左端补零。 对从最低有效位开始，到最高有效位的每一位数字排序。 第二步使用稳定排序算法来排序，如计数排序。其中一种方法是用桶分配和收集数位。我们使用十进制，因此使用 10 个桶，从 0 到 9 分别编号。将每个数字的个位按值分配到对应的桶中。然后将桶中的数字按序收集到辅助数组中。对每个数位进行分配和收集，最终得到完成排序的数组。 def radix_sort(a: list[int]) -\u003e list[int]: max_num = max(a) num_digits = len(str(max_num)) for i in range(num_digits): buckets = [[] for _ in range(10)] for num in a: digit = (num // 10 ** i) % 10 buckets[digit].append(num) a = [k for bucket in buckets for k in bucket] return a 基数排序需要分配的桶的数量与使用的进制的基数有关，设为 $k$。若数组长度为 $n$，则含有 $d$ 位数字数组每一位所需排序时间是 $O(n + r)$，因此总共所需时间为 $O((n + k) d)$。$d$ 和 $k$ 都是常数，因此基数排序的运行时间为 $O(n)$。所需空间最多为 $O(kn)$。 ","date":"2021-04-20","objectID":"/clrs-chap8/:2:0","tags":null,"title":"算法导论 Chap8：线性时间排序","uri":"/clrs-chap8/"},{"categories":null,"content":"桶排序 桶排序假设输入数据服从均匀分布，平均情况下运行时间为 $O(n)$。 def bucket_sort(a: list[float]) -\u003e list[float]: n = len(a) b = [[]] * n for i in range(n): b[i] = [] for i in range(1, n + 1): b[int(a[i - 1] * n)].append(a[i - 1]) for i in range(n): insertion_sort(b[i]) b = [i for j in b for i in j] return b 其中涉及 Python 数组扁平化1。常用方法有两层循环的列表推导、用 sum 合并到一个空数组、用 += 运算符合并每个子数组到一个空数组等。 桶排序同样属于稳定排序。 ","date":"2021-04-20","objectID":"/clrs-chap8/:3:0","tags":null,"title":"算法导论 Chap8：线性时间排序","uri":"/clrs-chap8/"},{"categories":null,"content":"排序的稳定性 我们已经学习了 9 种排序方法，其中选择排序、堆排序、快速排序都是不稳定的（还有一种不稳定的排序是第二章章末注记中提到的希尔排序）排序方法，其他都是稳定的。那么我们为什么要区分稳定排序和不稳定排序呢？ 答案是在实际应用中可能需要对同一组数据根据不同的关键字多次排序，使用稳定排序可以在多次排序后得到符合需求的数据排列方式。比如我们需要对 https://stackoverflow.com/questions/952914/ ↩︎ ","date":"2021-04-20","objectID":"/clrs-chap8/:4:0","tags":null,"title":"算法导论 Chap8：线性时间排序","uri":"/clrs-chap8/"},{"categories":["Algorithm"],"content":"堆是一个数组，可用近似完全二叉树1表示。表示堆的数组的两个属性： 数组长度； 堆大小。 堆大小表示数组中实际存储在堆中的数据。堆大小不小于 $0$，不大于数组长度。 class MaxHeap(list): def __init__(self, data: list[int]) -\u003e None: super().__init__(data) self.length = len(self) self.heap_size = self.length self.build_max_heap() 给定一个结点下标 $i$，则它的父结点下标 $\\lfloor i / 2\\rfloor$，左子结点下标 $2i$，右子结点下标 $2i + 1$。我们可以用三个简单的函数来计算父结点、左右子结点的下标。 def parent(i: int) -\u003e int: return (i - 1) // 2 def left(i: int) -\u003e int: return 2 * i + 1 def right(i: int) -\u003e int: return 2 * i + 2 二叉堆分为最大堆和最小堆，二者分别具有的性质： 最大堆中根结点最大；除了根结点以外，其他结点小于等于父结点。 最小堆中根结点最小；除了根结点以外，其他结点大于等于父结点。 堆中结点的高度（height）定义为该结点到叶结点最长简单路径上边的数量。堆的高度就是根结点的高度。 堆中结点的深度（depth）定义为该结点到根结点最长简单路径上边的数量。堆的深度就是叶结点的深度。 堆中结点的度（degree）定义为该结点的子结点数量。 堆的其他一些性质： 含 $n$ 个元素的堆的高度为 $h = \\lfloor \\lg n \\rfloor = \\Theta(\\lg n)$。 含 $n$ 个元素的堆的叶结点下标分别为 $\\lfloor n / 2 \\rfloor + 1, \\lfloor n / 2 \\rfloor + 2, \\cdots, n$。 含 $n$ 个元素的堆至多有 $\\left\\lceil \\cfrac{n}{2^{h + 1}} \\right\\rceil$ 个高度为 $h$ 的结点。 最大堆可以用来实现堆排序算法。最小堆通常用于构建优先级队列。 ","date":"2021-04-16","objectID":"/clrs-chap6/:0:0","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"堆排序 堆排序通过最大堆来实现。堆排序算法可以分为三个过程： max_hepify：维持最大堆的性质。 build_max_heap：从无序数组中构建最大堆。 heap_sort：堆排序过程。 ","date":"2021-04-16","objectID":"/clrs-chap6/:1:0","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"维持最大堆的性质 假设一个结点的左右子树（根结点分别为它的左右子结点）都是最大堆，但该结点可能比左右子结点小，此时就可以调用 max_heapify 将该结点在最大堆中「逐级下降」，直到以该结点为根结点的子树重新满足最大堆的性质为止。 def max_heapify(self, i: int) -\u003e None: l = self.left(i) r = self.right(i) if l \u003c= self.heap_size - 1 and self[l] \u003e self[i]: largest = l else: largest = i if r \u003c= self.heap_size - 1 and self[r] \u003e self[largest]: largest = r if largest != i: self[i], self[largest] = self[largest], self[i] self.max_heapify(largest) largest 表示某个结点 a[i] 和它的左右子结点中最大的结点的下标。根据大小关系可以分为两种情况： 如果 a[i] 就是最大的结点，那么堆已经是最大堆，结束程序。 如果 a[i] 的某个子结点是最大的结点，那么需要将它和这个子结点交换位置（最大堆的根结点最大）。交换位置以后，a[i] 元素的位置的下标是 largest。它在这个位置也可能不满足最大堆性质，因此需要在以它为根结点的子树上递归地调用 max_heapity。 max_heapify 的复杂度 在以 a[i] 为根结点，大小为 $n$ 的子树上调用 max_heapify 的运行时间包括： 调整 a[i] 和它的左右子结点需要 $O(1)$ 时间； 在以 a[i] 的子结点为根的子树上递归调用 max_heapify 的时间。最坏情况发生在该子结点的子树有最多结点的时候。此时 a[i] 子树的底层是半满的，左子结点的子树叶结点深度都比右子结点的子树大 1。 现在需要计算最坏情况下左子结点的子树结点数量。对于高度为 $h$ 的堆，元素个数最多为 $2^{h + 1} - 1$（也就是一棵完全二叉树），这个堆中高度为 $h$ 的结点个数为 $2^h$。设右子结点的子树结点数量为 $k$，则左边与之对称的部分也有 $k$ 个结点，左边剩下的最底层的结点个数 $x = \\cfrac{2^h}{2} = 2^{h - 1}$，而 $k = 2^h - 1 - x$，得 $k = 2^{h - 1} - 1$，因此 $x = k + 1$。 左子结点的子树结点个数为 $k + x = 2k + 1$。所有结点个数等于 a[i] 与左右子结点的子树结点数量之和，$n = 1 + (2k + 1) + k = 3k +2$，$k = \\cfrac{n - 2}{3}$。则 $2k + 1 = 2 \\cdot \\cfrac{n - 2}{3} + 1 = \\cfrac{2}{3} n - \\cfrac{1}{3}$。 我们现在知道了最坏情况下左子结点的子树结点数量，可以得到递归式 $T(n) \\leqslant T(2n / 3) + \\Theta(1)$。根据主定理得到解为 $T(n) = O(\\lg n)$。对于在树中高度为 $h$ 的结点来说，max_heapify 的时间复杂度是 $O(h)$。 ","date":"2021-04-16","objectID":"/clrs-chap6/:1:1","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"构建最大堆 利用 max_heapify 从一个数组自底向上地构建最大堆。因为每个叶结点都可以看作是只含一个元素的堆，它们的构建是平凡的，我们可以从叶结点的前一个结点开始遍历。从性质 2 可得叶结点的前一个结点的下标是 $\\lfloor n / 2 \\rfloor$，因此循环从数组下标 $\\lfloor n / 2 \\rfloor$ 逆向开始直到数组首元素，对区间中的每个结点调用 max_heapify： def build_max_heap(self) -\u003e None: self.heap_size = self.length for i in range(self.length // 2 - 1, -1, -1): self.max_heapify(i) 不同结点运行 max_heapify 的时间与它的高度有关，且高度都较小。利用性质 1 和 3，与级数微分公式 $A.8$ 可以得到 build_max_heap 的运行时间为： $$ \\sum_{h = 0}^{\\lfloor \\lg n \\rfloor} \\left\\lceil\\frac{n}{2^{h + 1}} \\right\\rceil O(h) = O\\left(n \\sum_{h = 0}^{\\lfloor \\lg n \\rfloor} \\frac{h}{2^h}\\right) = O\\left(n \\sum_{h = 0}^{\\infty} \\frac{h}{2^h}\\right) = O(n) $$ 因此 build_max_heap 函数的时间复杂度是 $O(n)$。 ","date":"2021-04-16","objectID":"/clrs-chap6/:1:2","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"堆排序过程 利用 build_max_heap 先将数组构建为最大堆，数组最大元素必然为 a[1]，然后将 a[1] 和 a[n] 交换。接着对前 $n - 1$ 个元素的子数组构建新的最大堆，交换首尾元素，重复这个过程直到堆的大小为 $2$。 def heap_sort(self) -\u003e None: self.build_max_heap() for i in range(self.length - 1, 0, -1): self[0], self[i] = self[i], self[0] self.heap_size -= 1 self.max_heapify(0) heap_sort 调用一次 build_max_heap，调用 $n - 1$ 次 max_heapify，因此 heap_sort 的时间复杂度是 $O(n \\lg n)$。 ","date":"2021-04-16","objectID":"/clrs-chap6/:1:3","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"优先级队列 优先级队列是一个集合，其中的每一个元素都有与之关联的值，称为键。优先级队列可以通过键来记录元素之间的相对优先级。优先级队列分为最大优先级队列和最小优先级队列。 最大优先级队列支持的操作： max_heap_insert：把元素插入到队列中。 heap_maximum：返回队列中键最大的元素。 heap_extract_max：从队列中移除并返回键最大的元素。 heap_increase_key：将元素的键增加到给定值，该值应当大于之前的值。 heap_maximum 过程： def heap_maximum(self) -\u003e int: return self[0] 最大堆的首元素是最大的，直接返回即可。 heap_extract_max 过程： def heap_extract_max(self) -\u003e int: if self.heap_size \u003c 1: sys.exit('heap underflow') maximum = self[0] self[0] = self[self.heap_size - 1] self.heap_size -= 1 self.max_heapify(0) return maximum 对大小小于 $1$ 的堆使用 heap_extract_max 应当报错。用 maximum 变量保存堆的最大值，然后将堆中最后一个元素放到堆的开头，并把堆的大小减一。调用 max_heapify 使堆保持最大堆性质。最后返回 maximum。 heap_increase_key 过程： def heap_increase_key(self, i: int, key: int | float) -\u003e None: if key \u003c self[i]: sys.exit('new key is smaller than current key') self[i] = key while i \u003e 0 and self[self.parent(i)] \u003c self[i]: self[self.parent(i)], self[i] = self[i], self[self.parent(i)] i = self.parent(i) 如果新的键小于原来的键，应当报错。将键更新后，为了维持最大堆性质，在当前结点到根结点的路径上寻找合适的位置插入这个新的键。每次比较当前元素和父结点的大小，如果当前元素的键较大，则与父结点的键交换。重复比较的过程直到当前元素的键小于父结点为止，此时堆符合最大堆性质。 max_heap_insert 过程： def max_heap_insert(self, key: int) -\u003e None: if self.heap_size \u003e= self.length: sys.exit('heap overflow') self.heap_size += 1 self[self.heap_size - 1] = float('-inf') self.heap_increase_key(self.heap_size - 1, key) 要插入元素时，将堆的大小加 $1$，先把元素放在堆的最后一个位置，键设为负无穷。然后调用 heap_increase_key 把元素的键的值增加到给定的值，这样就保持了堆的最大堆性质。 优先级队列的所有操作都可以在 $O(\\lg n)$ 时间内完成。 ","date":"2021-04-16","objectID":"/clrs-chap6/:2:0","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"本章难点 自底向上建堆的时间复杂度为 $O(n)$。 优先级队列的 heap_increase_key 过程能够保持最大堆性质。 CLRS 中定义的几种二叉树的名称和其他教材有差异，需要注意一下。CLRS 中常用的二叉树有：完全二叉树、近似完全二叉树和满二叉树。 ↩︎ ","date":"2021-04-16","objectID":"/clrs-chap6/:3:0","tags":["CLRS","Python"],"title":"算法导论 Chap6：堆、堆排序和优先级队列","uri":"/clrs-chap6/"},{"categories":["Algorithm"],"content":"本章讨论了当算法的运行时间不是算法重点时的分析方法。以雇用问题举例，每次对候选的应聘者进行比较，只要比上一位应聘者要好，就立即雇用，直到最后一位应聘者。我们感兴趣的是面试和雇用总共产生的费用。分析方法其实与分析算法运行时间是相同的，都是计算特定基本操作的执行次数。雇用问题算法 HIRE-ASSISTANT(n)： best = 0 for i = 1 to n interview candidate i if candidate i is better than candidate best best = i hire candidate i 假定面试的费用 $c_i$ 要小于雇用的费用 $c_h$，则根据最佳应聘者在所有应聘者中的面试顺序不同，雇用的费用也不同。最坏的情况是每位应聘者都比上一位要好，最佳应聘者是最后一位面试的应聘者。最好的情况是最佳应聘者是第一位应聘者。于是我们的问题是当应聘者以随机的顺序应聘时，应当如何分析雇用费用。 我们可以使用概率分析对这个问题进行分析。概率分析对输入的分布作出假设，然后进行分析，计算出一个平均情况下的运行时间。这个时间称为算法的平均情况运行时间。 因为我们要保证应聘顺序随机，可以使用随机数生成器对应聘者的顺序进行排列。 随机算法的定义：行为由输入和随机数生成器产生的数值同时决定的算法。 随机算法的运行时间称为期望运行时间。 ","date":"2021-04-15","objectID":"/clrs-chap5/:0:0","tags":["CLRS"],"title":"算法导论 Chap5：概率分析和随机算法","uri":"/clrs-chap5/"},{"categories":["Algorithm"],"content":"指示器随机变量 指示器随机变量（indicator random variable）用于概率和期望之间的转换，简化算法分析过程。 引理 5.1：给定一个样本空间 $S$ 和 $S$ 中的一个事件 $A$，设 $X_A = I{A}$，则 $E[X_A] = Pr{A}$。 雇用问题的期望 $E[X] = \\ln n + O(1)$。 引理 5.2：假设应聘者以随机顺序出现，算法 HIRE-ASSISTANT 总的雇用费用在平均情况下为 $O(c_n \\ln n)$。 ","date":"2021-04-15","objectID":"/clrs-chap5/:1:0","tags":["CLRS"],"title":"算法导论 Chap5：概率分析和随机算法","uri":"/clrs-chap5/"},{"categories":["Algorithm"],"content":"随机算法 雇用问题的随机算法是确定性的，对于任何特定的输入 $n$，雇用的次数始终相等，都是 $\\ln n$。并且随机方式在算法上，而非输入分布上。 雇用问题随机算法 RANDOMIZED-HIRE-ASSISTANT(n)： randomly permute the list of candidates best = 0 for i = i to n interview candidate i if candidate i is better than candidate best best = i hire candidate i 引理 5.3：过程 RANDOMIZED-HIRE-ASSISTANT 的雇用费用期望是 $O(c_h \\ln n)$。 随机排列数组的两种方法： 为数组的每个元素 $A[i]$ 赋予一个随机的优先级 $P[i]$，然后根据优先级对数组 $A$ 中的元素进行排序。 原地排列给定数组。 第一种方法的排序过程 PERMUTE-BY-SORTING(A)： n = A.length let P[1..n] be a new array for i = 1 to n P[i] = RANDOM(1, n^3) sort A, using P as sort keys 引理 5.4：假设所有优先级都不同，则过程 PERMUTE-BY-SORTING(A) 产生输入的均匀随机排序。 第二种方法更好，它的原地排列过程 RANDOMIZE-IN-PLACE(A)： n = A.length for i = 1 to n swap A[i] with A[RANDOM(i, n)] 引理 5.5：过程 RANDOMIZE-IN-PLACE 可计算出一个均匀随机排列。 ","date":"2021-04-15","objectID":"/clrs-chap5/:2:0","tags":["CLRS"],"title":"算法导论 Chap5：概率分析和随机算法","uri":"/clrs-chap5/"},{"categories":["Algorithm"],"content":"分治策略 分治策略的三个步骤： 分解：分解原问题为形式相同但规模更小的子问题； 解决：递归求解子问题，对规模足够小的子问题直接求解； 合并：合并子问题的解，得到原问题的解。 子问题的两种情况： 递归情况：当子问题足够大，需要递归求解的情况； 基本情况：子问题变得足够小，不再需要递归求解的情况。 对于与原问题形式不同的子问题的求解视为合并步骤的一部分。 递归式是一个等式或不等式，通过更小的输入上的函数值来描述一个函数。 例 1 归并排序的递归式： $$ T(n) = \\begin{cases} \\Theta(1) \u0026 若\\ n = 1, \\\\ 2T(n / 2) + \\Theta(n) \u0026 若\\ n \u003e 1. \\end{cases} $$ 递归求解可得 $T(n) = \\Theta(n\\lg n)$。 例 2 规模不等的子问题。如将子问题划分为 $\\cfrac{2}{3}$ 和 $\\cfrac{1}{3}$，假设分解和合并步骤都是线性时间的，则得到的递归式： $$ T(n) = T(2n / 3) + T(n / 3) = \\Theta(n) $$ 例 3 递归的线性查找。线性查找的递归版本仅生成一个子问题，其规模仅比原问题的规模少一个元素。每次递归调用将花费常量时间加上下一层递归调用的时间。因此递归式为： $$ T(n) = T(n - 1) + \\Theta(1) = \\Theta(n) $$ 获取递归式的 $\\Theta$ 或 $O$ 渐近界的三种求解方式： 代入法（substitution method）首先猜测一个界，然后用数学归纳法证明。 递归树法（recursion-tree method）将递归式转换成一棵树，以结点表示不同层次递归产生的代价。然后用界之和（bounding summation）的技术求解递归式。 主方法（master method）求解 $T(n) = aT(n / b) + f(n)$ 形式的递归式的界，其中 $a \\geqslant 1$，$b \u003e 1$，$f(n)$ 是给定的函数。分治算法将原问题分为 $a$ 个子问题，每个子问题都是原问题规模的 $\\cfrac{1}{b}$，分解与合并步骤总共需要 $f(n)$ 时间。 当递归式是不等式时，可以用 $O$ 或 $\\Omega$ 来描述递归式的解。 当声明和求解递归式时，通常忽略向上、下取整和边界条件这些对结果影响不大的细节。 ","date":"2021-04-10","objectID":"/clrs-chap4/:1:0","tags":["CLRS","Python"],"title":"算法导论 Chap4：分治策略","uri":"/clrs-chap4/"},{"categories":["Algorithm"],"content":"最大子数组问题 最大子数组问题要寻找一个数组的最大子数组。 最大子数组的定义：一个数组的非空子数组，该子数组的元素之和是所有子数组中最大的。 一个数组可能有多个最大子数组。 只有数组中包含负数时，最大子数组问题才有意义。 寻找最大子数组可以采用分治策略，效仿第二章的思考题 2-4 寻找逆序对，它一定在数组 $A$ 的左半边，或右半边，或跨越数组中点。前两种情况可以递归求解，因为这两个子问题也是相同形式的最大子数组问题，只是规模更小。因此主要处理的是寻找跨越数组中点的最大子数组的情况，然后在三种情况中选取最大的那个子数组，即为 $A$ 的最大子数组。 对于跨越子数组 $A[low..high]$ 中点的最大子数组，由中点左边部分的子数组 $A[i..mid]$ 和右边部分的子数组 $A[mid+1..j]$ 组成。 def find_max_crossing_subarray( a: list[int], low: int, mid: int, high: int ) -\u003e tuple[int, int, int | float]: left_sum = float('-inf') sum: int = 0 for i in range(mid, low - 1, -1): sum = sum + a[i] if sum \u003e left_sum: left_sum = sum max_left = i right_sum = float('-inf') sum2: int = 0 for j in range(mid + 1, high + 1): sum2 = sum2 + a[j] if sum2 \u003e right_sum: right_sum = sum2 max_right = j return (max_left, max_right, left_sum + right_sum) find_max_crossing_subarray 所需时间为 $\\Theta(n)$。 我们现在能够对最大子数组的三种情况进行处理了，接下来就可以定义寻找最大子数组的函数 find_maximum_subarray： def find_maximum_subarray( a: list[int], low: int, high: int ) -\u003e tuple[int, int, int | float]: if high == low: return (low, high, a[low]) else: mid = (low + high) // 2 left_low, left_high, left_sum = find_maximum_subarray(a, low, mid) right_low, right_high, right_sum = find_maximum_subarray(a, mid + 1, high) cross_low, cross_high, cross_sum = find_max_crossing_subarray(a, low, mid, high) if left_sum \u003e= right_sum and left_sum \u003e= cross_sum: return (left_low, left_high, left_sum) elif right_sum \u003e= left_sum and right_sum \u003e= cross_sum: return (right_low, right_high, right_sum) else: return (cross_low, cross_high, cross_sum) 最后定义一个快捷地对整个数组寻找最大子数组的函数 maximum_subarray，便于测试： def maximum_subarray(a: list[int]) -\u003e tuple[int, int, int | float]: return find_maximum_subarray(a, 0, len(a) - 1) 第 2 节矩阵乘法的 Strassen 算法跳过。 ","date":"2021-04-10","objectID":"/clrs-chap4/:2:0","tags":["CLRS","Python"],"title":"算法导论 Chap4：分治策略","uri":"/clrs-chap4/"},{"categories":["Algorithm"],"content":"用代入法求解递归式 代入法的两个步骤： 猜测解的形式。 用数学归纳法求出解中的常数，并证明解是正确的。 ","date":"2021-04-10","objectID":"/clrs-chap4/:3:0","tags":["CLRS","Python"],"title":"算法导论 Chap4：分治策略","uri":"/clrs-chap4/"},{"categories":["Algorithm"],"content":"用递归树方法求解递归式 在递归树中，每个结点表示单个子问题的代价，子问题对应某次递归函数的调用。将树中每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到所有层次的递归调用的总代价。 递归树可以用来生成好的猜测，然后用代入法来验证猜测是否正确。 ","date":"2021-04-10","objectID":"/clrs-chap4/:4:0","tags":["CLRS","Python"],"title":"算法导论 Chap4：分治策略","uri":"/clrs-chap4/"},{"categories":["Algorithm"],"content":"用主方法求解递归式 主方法用于求解形如 $T(n) = aT(n / b) + f(n)$ 的递归式。其中 $a \\geqslant 1$ 和 $b \u003e 1$ 且为常量，$f(n)$ 是渐近正函数。$a$ 表示将规模为 $n$ 分解后的子问题的个数，$b$ 表示每个子问题的规模是原问题的 $n / b$，$f(n)$ 表示问题分解和子问题的解合并所需的代价。 主定理：令 $a \\geqslant 1$ 和 $b \u003e 1$ 为常量，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式： $$ T(n) = aT(\\frac{n}{b}) + f(n) $$ 其中 $\\cfrac{n}{b}$ 意为 $\\lfloor \\cfrac{n}{b} \\rfloor$ 或 $\\lceil \\cfrac{n}{b} \\rceil$。则 $T(n)$ 具有如下渐近界： 若对某个常数 $\\epsilon \u003e 0$ 有 $f(n) = O(n^{\\log_b{a - \\epsilon}})$，则 $T(n) = \\Theta(n^{\\log_b{a}})$。 若 $f(n) = \\Theta(n^{\\log_b{a}})$，则 $T(n) = \\Theta(n^{\\log_b{a}} \\lg n)$。 若对某个常数 $\\epsilon \u003e 0$ 有渐近正函数 $f(n) = \\Omega(n^{\\log_b{a + \\epsilon}})$，且对某个常量 $c \u003c 1$ 和所有足够大的 $n$ 有 $af(\\cfrac{n}{b}) \\leqslant cf(n)$，则 $T(n) = \\Theta(f(n))$。 通过比较函数 $f(n)$ 与函数 $n^{\\log_b{a}}$ 的大小来匹配三种情况之一。较大者决定递归式的解。$n^{\\log_b{a}}$ 更大有情况 1，$f(n)$ 更大有情况 3，大小相等则有情况 2。这里的大小比较是多项式意义上的比较。 三种情况未完全覆盖 $f(n)$ 的所有可能性。1 和 2 与 2 和 3 之间分别可能存在间隙。只有保证间隙也在多项式意义上大小关系一致，才能使用主定理。 ","date":"2021-04-10","objectID":"/clrs-chap4/:5:0","tags":["CLRS","Python"],"title":"算法导论 Chap4：分治策略","uri":"/clrs-chap4/"},{"categories":["Algorithm"],"content":"3.1 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:0","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-1 因为 $f(n)$ 和 $g(n)$ 都是渐近非负的，所以对于 $f(n)$ 和 $g(n)$ 有： $$ \\begin{aligned} \\exists n_1:\\quad f(n) \u0026 \\geqslant 0\\quad \\text{for all}\\ n \u003e n_1 \\\\ \\exists n_2:\\quad g(n) \u0026 \\geqslant 0\\quad \\text{for all}\\ n \u003e n_2 \\end{aligned} $$ 令 $n_0 = \\max(n_1, n_2)$，则对于 $n \u003e n_0$，下列不等式成立： $$ \\begin{aligned} f(n) \u0026 \\leqslant \\max(f(n), g(n)) \\\\ g(n) \u0026 \\leqslant \\max(f(n), g(n)) \\\\ \\frac{1}{2}(f(n) + g(n)) \u0026 \\leqslant \\max(f(n), g(n)) \\\\ \\max(f(n), g(n)) \u0026 \\leqslant (f(n) + g(n)) \\end{aligned} $$ 结合后两个不等式得： $$ 0 \\leqslant \\frac{1}{2}(f(n) + g(n)) \\leqslant \\max{(f(n), g(n))} \\leqslant f(n) + g(n). $$ 即当 $c_1 = \\frac{1}{2}$ 和 $c_2 = 1$ 时，$\\Theta{(f(n) + g(n))}$ 的定义。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:1","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-2 将 $(n + a)^b$ 以二项式展开，得： $$ (n + a)^b = C_0^b n^b a^0 + C_1^b n^{b - 1} a^1 + \\cdots + C_b^b n^0 a^b. $$ 对二项式成立的一个不等式是对于 $x \\geqslant 1$，有： $$ a_0 x^0 + a_1 x^1 + \\cdots + a_n x^n \\leqslant (a_0 + a_1 + \\cdots + a_n) x^n. $$ 因此可得： $$ \\begin{aligned} C_0^b n^b \u0026 \\leqslant C_0^b n^b a^0 + C_1^b n^{b - 1} a^1 + \\cdots + C_b^b n^0 a^b \\\\ \u0026 \\leqslant (C_0^b + C_1^b + \\cdots + C_b^b) n^b = 2^b n^b. \\end{aligned} $$ 从而 $(n + a)^b = \\Theta(n^b).$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:2","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-3 这个句子对于算法 $A$ 的上下界都没有准确描述。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:3","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-4 （1）$2^{n + 1} = 2 \\times 2^n$。令 $c \\geqslant 2, n_0 = 0$，使得对所有 $n \\geqslant n_0$ 有 $0 \\leqslant 2^{n + 1} \\leqslant c \\times 2^n$。根据定义，$2^{n + 1} = O(2^n)$，因此为真。 （2）$2^{2n} = 2^n \\times 2^n = 4^n$。无法找到任何 $c$ 和 $n_0$ 使得 $0 \\leqslant 2^{2^n} = 4^n \\leqslant c \\times 2^n$ 对所有 $n \\geqslant n_0$ 成立。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:4","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-5 充分性：因为 $f(n) = \\Theta(g(n))$，有 $0 \\leqslant c_{1}g(n) \\leqslant f(n) \\leqslant c_{2}g(n)$ 对所有 $n \\geqslant n_0$ 都成立。 由 $0 \\leqslant c_{1}g(n) \\leqslant f(n)$ 可得 $f(n) = O(g(n))$；由 $0 \\leqslant f(n) \\leqslant c_{2}g(n)$ 可得 $f(n) = \\Omega(g(n))$。 必要性：因为 $f(n) = O(g(n))$ 且 $f(n) = \\Omega(g(n))$，有： $$ \\begin{aligned} 0 \\leqslant c_{1}'g(n) \\leqslant f(n)\\ 对所有\\ n \\geqslant n_1\\ 成立 \\\\ 0 \\leqslant f(n) \\leqslant c_{2}'g(n)\\ 对所有\\ n \\geqslant n_2\\ 成立 \\end{aligned} $$ 令 $n_0’ = \\max(n_1,n_2)$，合并不等式得： $$ 0 \\leqslant c_{1}'g(n) \\leqslant f(n) \\leqslant c_{2}'g(n)\\ 对所有\\ n \\geqslant n_0'\\ 成立. $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:5","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-6 证明同 3.1-5。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:6","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-7 根据定义有 $0 \\leqslant o(g(n)) \u003c ch(n)$，$0 \\leqslant ch(n) \u003c \\omega(g(n))$。因此 $o(g(n)) \u003c \\omega(g(n))$，故 $o(g(n)) \\cap \\omega(g(n)) = \\emptyset$。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:7","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.1-8 $$ \\begin{aligned} \\Omega(g(n,m)) = \\{f(n,m): \u0026 存在正常量\\ c,n_0\\ 和\\ m_0 \\\\ \u0026 使得\\ 0 \\leqslant cg(n,m) \\leqslant f(n,m) \\\\ \u0026 对所有\\ n \\geqslant n_0\\ 或\\ m \\geqslant m_0\\ 成立\\} \\\\ \\end{aligned} $$ $$ \\begin{aligned} \\Theta(g(n,m)) = \\{f(n,m): \u0026 存在正常量\\ c_1,c_2,n_0\\ 和\\ m_0 \\\\ \u0026 使得\\ 0 \\leqslant c_1g(n,m) \\leqslant f(n,m) \\leqslant c_2g(n,m) \\\\ \u0026 对所有\\ n \\geqslant n_0\\ 或\\ m \\geqslant m_0\\ 成立\\} \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:1:8","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:0","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-1 （1）因为 $f(n)$ 和 $g(n)$ 都是单调递增函数，所以当 $n_1 \\leqslant n_2$ 时，有 $f(n_1) \\leqslant f(n_2)$ 和 $g(n_1) \\leqslant g(n_2)$。另外令 $g(n_1) = m_1$， $g(n_2) = m_2$， 有 $m_1 \\leqslant m_2$。综上可得： $$ f(n_1) + g(n_1) \\leqslant f(n_2) + g(n_1) \\leqslant f(n_2) + g(n_2) \\ f(m_1) \\leqslant f(m_2) $$ 故 $f(n) + g(n)$ 和 $f(g(n))$ 都是单调递增的。 （2）因为 $f(n)$ 和 $g(n)$ 都是非负的，所以有： $$ f(n_1) \\cdot g(n_1) \\leqslant f(n_2) \\cdot g(n_1) \\leqslant f(n_2) \\cdot g(n_2) $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:1","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-2 $$ \\begin{aligned} a^{\\log_{b}{c}} \u0026 = (c^{\\log_{c}{a}})^{\\log_{b}{c}} \\\\ \u0026 = c^{\\log_{c}{a} \\cdot {\\log_{b}{c}}} \\\\ \u0026 = c^{\\frac{\\log_{c}{a}}{\\log_{c}{b}}} \\\\ \u0026 = c^{\\log_{b}{a}} \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:2","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-3 （1）证明 $\\lg(n!) = \\Theta(n \\lg n)$： $$ \\begin{aligned} \\lg(n!) \u0026 = \\lg\\left(\\sqrt{2\\pi n}\\left(\\frac{n}{e}\\right)^n\\left(1 + \\Theta\\left(\\frac{1}{n}\\right)\\right)\\right) \\\\ \u0026 = \\lg\\sqrt{2\\pi n } + \\lg\\Big(\\frac{n}{e}\\Big)^n + \\lg\\left(1+\\Theta\\left(\\frac{1}{n}\\right)\\right) \\\\ \u0026 = \\Theta(\\sqrt n) + n\\lg{\\frac{n}{e}} + \\lg\\left(\\Theta(1) + \\Theta\\left(\\frac{1}{n}\\right)\\right) \\\\ \u0026 = \\Theta(\\sqrt n) + \\Theta(n\\lg n) + \\Theta\\left(\\frac{1}{n}\\right) \\\\ \u0026 = \\Theta(n\\lg n) \\end{aligned} $$ （2）证明 $n! = \\omega(2^n)$： $$ \\begin{aligned} \\lim_{n \\to \\infty} \\frac{2^n}{n!} \u0026 = \\lim_{n \\to \\infty} \\frac{2^n}{\\sqrt{2 \\pi n} \\left(\\frac{n}{e}\\right)^n \\left(1 + \\Theta\\left(\\frac{1}{n}\\right)\\right)} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{1}{\\sqrt{2 \\pi n} \\left(1 + \\Theta\\left(\\frac{1}{n}\\right)\\right)} \\left(\\frac{2e}{n}\\right)^n \\\\ \u0026 \\leqslant \\lim_{n \\to \\infty} \\left(\\frac{2e}{n}\\right)^n \\\\ \u0026 \\leqslant \\lim_{n \\to \\infty} \\frac{1}{2^n} = 0 \u0026 \\text{for $n \u003e 4e$} \\end{aligned} $$ 证明 $n! = o(n^n)$： $$ \\begin{aligned} \\lim_{n \\to \\infty} \\frac{n^n}{n!} \u0026 = \\lim_{n \\to \\infty} \\frac{n^n}{\\sqrt{2 \\pi n} \\left(\\frac{n}{e}\\right)^n \\left(1 + \\Theta\\left(\\frac{1}{n}\\right)\\right)} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{e^n}{\\sqrt{2 \\pi n} \\left(1 + \\Theta\\left(\\frac{1}{n}\\right)\\right)} \\\\ \u0026 = \\lim_{n \\to \\infty} O\\left(\\frac{1}{\\sqrt n}\\right)e^n \\\\ \u0026 \\geqslant \\lim_{n \\to \\infty} \\frac{e^n}{c\\sqrt n} \u0026 \\text{(for some constant $c \u003e 0$)} \\\\ \u0026 \\geqslant \\lim_{n \\to \\infty} \\frac{e^n}{cn} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{e^n}{c} = \\infty \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:3","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-4 $\\star$ （1）如果 $f(n)$ 是多项式有界的，则存在常量 $c$，$k$，$n_0$ 使得对所有 $n \\geqslant n_0$，有 $f(n) \\leqslant cn^k$。因此 $\\lg(f(n)) \\leqslant kc \\lg n$，即 $\\lg(f(n)) = O(\\lg n)$。所以如果 $\\lg(f(n)) = O(\\lg n)$，那么 $f(n)$ 就是多项式有界的。 因为 $\\lg(n!) = \\Theta(n \\lg n)$，$\\lceil \\lg n \\rceil = \\Theta(\\lg n)$，得： $$ \\begin{aligned} \\lg(\\lceil \\lg n \\rceil!) \u0026 = \\Theta(\\lceil \\lg n \\rceil \\lg \\lceil \\lg n \\rceil) \\\\ \u0026 = \\Theta(\\lg n \\lg\\lg n) \\\\ \u0026 = \\omega(\\lg n) \\\\ \u0026 \\ne O(\\lg n) \\end{aligned} $$ 所以 $\\lceil \\lg n \\rceil!$ 不是多项式有界的。 （2）同样按照（1）中的分析，可得： $$ \\begin{aligned} \\lg(\\lceil \\lg\\lg n \\rceil!) \u0026 = \\Theta(\\lceil \\lg\\lg n \\rceil \\lg \\lceil \\lg\\lg n \\rceil) \\\\ \u0026 = \\Theta(\\lg\\lg n\\lg\\lg\\lg n) \\\\ \u0026 = o((\\lg\\lg n)^2) \\\\ \u0026 = o(\\lg^2(\\lg n)) \\\\ \u0026 = o(\\lg n) \\\\ \u0026 = O(\\lg n) \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:4","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-5 $\\star$ $$ \\begin{aligned} \\lim_{n \\to \\infty} \\frac{\\lg(\\lg^*n)}{\\lg^*(\\lg n)} \u0026 = \\lim_{n \\to \\infty} \\frac{\\lg(\\lg^* 2^n)}{\\lg^*(\\lg 2^n)} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{\\lg(1 + \\lg^* n)}{\\lg^* n} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{\\lg(1 + n)}{n} \\\\ \u0026 = \\lim_{n \\to \\infty} \\frac{1}{1 + n} \\\\ \u0026 = 0 \\end{aligned} $$ 所以 $\\lg^{*}(\\lg n)$ 更大。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:5","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-6 $$ \\begin{aligned} \\phi^2 \u0026 = \\left(\\frac{1 + \\sqrt 5}{2}\\right)^2 = \\frac{6 + 2\\sqrt 5}{4} = 1 + \\frac{1 + \\sqrt 5}{2} = 1 + \\phi \\\\ \\hat\\phi^2 \u0026 = \\left(\\frac{1 - \\sqrt 5}{2}\\right)^2 = \\frac{6 - 2\\sqrt 5}{4} = 1 + \\frac{1 - \\sqrt 5}{2} = 1 + \\hat\\phi \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:6","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-7 基本情况：对于 $i = 0$，有： $$ \\frac{\\phi^0 - \\hat\\phi^0}{\\sqrt 5} = \\frac{1 - 1}{\\sqrt 5} = 0 = F_0 $$ 对于 $i = 1$，有： $$ \\frac{\\phi^1 - \\hat\\phi^1}{\\sqrt 5} = \\frac{(1 + \\sqrt 5) - (1 - \\sqrt 5)}{2 \\sqrt 5} = 1 = F_1 $$ 假设 $F_{i - 1} = \\cfrac{\\phi^{i - 1} - \\hat\\phi^{i - 1}}{\\sqrt 5}$ 和 $F_{i - 2} = \\cfrac{\\phi^{i - 2} - \\hat\\phi^{i - 2}}{\\sqrt 5}$ 成立，则： $$ \\begin{aligned} F_i \u0026 = F_{i - 1} + F_{i - 2} \\\\ \u0026 = \\frac{\\phi^{i - 1} - \\hat\\phi^{i - 1}}{\\sqrt 5} + \\frac{\\phi^{i - 2} - \\hat\\phi^{i - 2}}{\\sqrt 5} \\\\ \u0026 = \\frac{\\phi^{i - 2}(\\phi + 1) - \\hat\\phi^{i - 2}(\\hat\\phi + 1)}{\\sqrt 5} \\\\ \u0026 = \\frac{\\phi^{i - 2}\\phi^2 - \\hat\\phi^{i - 2}\\hat\\phi^2}{\\sqrt 5} \\\\ \u0026 = \\frac{\\phi^i - \\hat\\phi^i}{\\sqrt 5} \\end{aligned} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:7","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3.2-8 利用 $\\Theta$ 记号的对称性，可得： $$ k \\ln k = \\Theta(n) \\Rightarrow n = \\Theta(k \\ln k) $$ 则： $$ \\ln n = \\Theta(\\ln(k \\ln k)) = \\Theta(\\ln k + \\ln\\ln k) = \\Theta(\\ln k) $$ 从而： $$ \\cfrac{n}{\\ln n} = \\cfrac{\\Theta(k \\ln k)}{\\Theta(\\ln k)} = \\Theta\\left({\\cfrac{k \\ln k}{\\ln k}}\\right) = \\Theta(k) $$ 再利用对称性，得： $$ \\cfrac{n}{\\ln n} = \\Theta(k) \\Rightarrow k = \\Theta\\left(\\cfrac{n}{\\ln n}\\right) $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:2:8","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"思考题 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:0","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-1 a. 需要选择 $c$ 使得： $$ \\sum\\limits_{i = 0}^d a_i n^i = a_d n^d + a_{d - 1}n^{d - 1} + \\cdots + a_1n + a_0 \\leqslant cn^d $$ 不等式两边除以 $n^d$，得： $$ c \\geqslant a_d + \\frac{a_{d - 1}}n + \\frac{a_{d - 2}}{n^2} + \\cdots + \\frac{a_0}{n^d} $$ 令 $c = a_d + b$，则： $$ \\begin{aligned} a_d + b \u0026 \\geqslant a_d + \\frac{a_{d - 1}}n + \\frac{a_{d - 2}}{n^2} + \\cdots + \\frac{a_0}{n^d} \\\\ b \u0026 \\geqslant \\frac{a_{d - 1}}n + \\frac{a_{d - 2}}{n^2} + \\cdots + \\frac{a_0}{n^d} \\end{aligned} $$ 若令 $b = 1$，则可得 $n_0$ 的值： $$ n_0 = \\max(da_{d - 1}, d\\sqrt{a_{d - 2}}, \\dots, d\\sqrt[d]{a_0}) $$ 对于 $n \\geqslant n_0$： $$ p(n) \\leqslant cn^d $$ 即 $O(n^d)$ 的定义。故当 $k \\geqslant d$，$p(n) = O(n^k)$。 b. 令 a 中的 $b = -1$，同理可得 $\\Omega$ 记号的定义。 c. 综合 a 和 b 可得 $\\Theta$ 记号的定义。 d. 同理。 e. 同理。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:1","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-2 $A$ $B$ $O$ $o$ $\\Omega$ $\\omega$ $\\Theta$ $\\lg^k n$ $n^{\\epsilon}$ yes yes no no no $n^k$ $c^n$ yes yes no no no $\\sqrt{n}$ $n^{\\sin n}$ no no no no no $2^n$ $2^{n / 2}$ no no yes yes no $n^{\\lg c}$ $c^{\\lg n}$ yes no yes no yes $\\lg(n!)$ $\\lg(n^n)$ yes no yes no yes ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:2","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-3 a. $$ \\begin{array}{ll} 2^{2^{n + 1}}, \u0026 \\\\ 2^{2^n}, \u0026 \\\\ (n + 1)!, \u0026 \\\\ n!, \u0026 \\\\ e^n, \u0026 \\\\ n\\cdot 2^n, \u0026 \\\\ 2^n, \u0026 \\\\ (3 / 2)^n, \u0026 \\\\ (\\lg n)^{\\lg n} = n^{\\lg\\lg n}, \u0026 \\\\ (\\lg n)!, \u0026 \\\\ n^3, \u0026 \\\\ n^2 = 4^{\\lg n}, \u0026 \\\\ n\\lg n \\text{ and } \\lg(n!), \u0026 \\\\ n = 2^{\\lg n}, \u0026 \\\\ (\\sqrt 2)^{\\lg n}\\quad (= \\sqrt n), \u0026 \\\\ 2^{\\sqrt{2\\lg n}}, \u0026 \\\\ \\lg^2 n, \u0026 \\\\ \\ln n, \u0026 \\\\ \\sqrt{\\lg n}, \u0026 \\\\ \\ln\\ln n, \u0026 \\\\ 2^{\\lg^*n}, \u0026 \\\\ \\lg^*n \\text{ and } \\lg^*(\\lg n), \u0026 \\\\ \\lg(\\lg^*n), \u0026 \\\\ n^{1 / \\lg n}\\quad (= 2) \\text{ and } 1. \u0026 \\end{array} $$ b. $$ f(n) = \\begin{cases} 2^{2^{n + 2}} \u0026 \\text{if $n$ is even}, \\\\ 0 \u0026 \\text{if $n$ is odd}. \\end{cases} $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:3","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-4 a. 不成立。如 $n = O(n^2)$，但 $n^2 \\ne O(n)$。 b. 不成立。如 $n^2 + n \\ne \\Theta(\\min(n^2, n)) = \\Theta(n)$。 c. 成立。因为对 $n \\geqslant n_0$ 有 $f(n) \\geqslant 1$。 $$ \\exists c, n_0: \\forall n \\geqslant n_0, 0 \\leqslant f(n) \\leqslant cg(n). $$ 可得： $$ 0 \\leqslant \\lg f(n) \\leqslant \\lg(cg(n)) = \\lg c + \\lg(g(n)) $$ 现在需要证明存在常量 $c’$ 使得 $\\lg(f(n)) \\leqslant c’ \\lg(g(n))$。 因为 $\\lg(g(n)) \\geqslant 1$，所以： $$ c’ = \\frac{\\lg c + \\lg(g(n))}{\\lg(g(n))} = \\frac{\\lg c}{\\lg(g(n))} + 1 \\leqslant \\lg c + 1 $$ 常量 $c’$ 存在，故命题成立。 d. 不成立。如 $2n = O(n)$，但 $2^{2n} = 4^n \\ne O(2^n)$。 e. 成立。当 $f(n) \\geqslant 1$ 时，对所有 $n \\geqslant 1$ 来说 $0 \\leqslant f(n) \\leqslant cf^2(n)$ 是平凡的。 f. 成立。首先有 $0 \\leqslant f(n) \\leqslant cg(n)$，需要证明存在常量 $c’$ 使得 $0 \\leqslant c’ f(n) \\leqslant g(n)$。当 $c’ = \\cfrac{1}{c}$ 时明显成立。 g. 不成立。令 $f(n) = 2^n$，则需要证明下面的不等式成立： $$ \\exists c_1, c_2, n_0: \\forall n \\geqslant n_0, 0 \\leqslant c_1 \\cdot 2^{n / 2} \\leqslant 2^n \\leqslant c_2 \\cdot 2^{n / 2}. $$ 不等式同除以 $2^{n / 2}$，得： $$ c_1 \\leqslant 2^{n / 2} \\leqslant c_2 $$ 因为 $c_2$ 为常量，对任意大的 $n$，不等式不可能成立。 h. 成立。令 $g(n) = o(f(n))$，有： $$ \\exists c, n_0: \\forall n \\geqslant n_0, 0 \\leqslant g(n) \u003c cf(n). $$ 需要证明： $$ \\exists c_1, c_2, n_0: \\forall n \\geqslant n_0, 0 \\leqslant c_1f(n) \\leqslant f(n) + g(n) \\leqslant c_2f(n). $$ 令 $c_1 = 1$，$c_2 = c + 1$，不等式成立。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:4","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-5 a. $$ f(n) = \\begin{cases} O(g(n)) \\text{ and } \\mathop \\Omega \\limits^\\infty(g(n)) \u0026 \\text{if $f(n) = \\Theta(g(n))$}, \\\\ O(g(n)) \u0026 \\text{if $0 \\leqslant f(n) \\leqslant cg(n)$}, \\\\ \\mathop \\Omega \\limits^\\infty(g(n)) \u0026 \\text{if $0 \\leqslant cg(n) \\leqslant f(n)$, 对无穷多的整数 $n$}. \\end{cases} $$ b. 优点：可以刻画所有函数之间的关系。 缺点：刻画不够精确。 c. 对任意两个函数 $f(n)$ 和 $g(n)$，如果 $f(n) = \\Theta(g(n))$，有： $$ \\begin{aligned} f(n) \u0026 = O'(g(n)) \\\\ f(n) \u0026 = \\Omega(g(n)) \\\\ \\end{aligned} $$ 反之则不成立。 d. $\\tilde\\Omega$ 记号的定义： $$ \\begin{aligned} \\tilde\\Omega(g(n)) = \\{f(n): \u0026\\ 存在正常量\\ c, k\\ 和\\ n_0\\ 使得对所有\\ n \\geqslant n_0\\ 有 \\\\ \u0026 0 \\leqslant cg(n)\\lg^k(n) \\leqslant f(n)\\}. \\end{aligned} $$ $\\tilde\\Theta$ 记号的定义： $$ \\begin{aligned} \\tilde{\\Theta}(g(n)) = \\{f(n): \u0026\\ 存在正常量\\ c_1, c_2, k_1, k_2\\ 和\\ n_0\\ 使得对所有\\ n \\geqslant n_0\\ 有 \\\\ \u0026 0 \\leqslant c_1 g(n) \\lg^{k_1}(n) \\leqslant f(n) \\leqslant c_2g (n) \\lg^{k_2}(n) \\}. \\end{aligned} $$ 对任意两个函数 $f(n)$ 和 $g(n)$，有： $$ f(n) = \\tilde\\Theta(g(n)) $$ 当且仅当： $$ f(n) = \\tilde O(g(n))\\quad \\text{and}\\quad f(n) = \\tilde\\Omega(g(n)) $$ ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:5","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"3-6 $f(n)$ $c$ $f_c^*(n)$ $n-1$ 0 $\\Theta(n)$ $\\lg n$ 1 $\\Theta(\\lg^* n)$ $n / 2$ 1 $\\Theta(\\lg n)$ $n / 2$ 2 $\\Theta(\\lg n)$ $\\sqrt n$ 2 $\\Theta(\\lg \\lg n)$ $\\sqrt n$ 1 NA $n^{1 / 3}$ 2 $\\Theta(\\log_3 \\lg n)$ $n / \\lg n$ 2 $\\omega(\\lg \\lg n)$，$o(\\lg n)$ 参考答案：https://github.com/walkccc/CLRS。 ","date":"2021-04-07","objectID":"/clrs-chap3-exercises/:3:6","tags":["CLRS"],"title":"算法导论 Chap3 习题","uri":"/clrs-chap3-exercises/"},{"categories":["Algorithm"],"content":"渐近记号 当算法的输入规模足够大时，运行时间与增长量级密切相关。此时，需要通过渐近分析来研究输入规模趋近无限时，算法的运行时间如何随输入规模的变大而增加。 渐近分析使用渐近记号描述算法的运行时间，根据定义域为自然数集的函数来定义渐近记号。有时按照各种方式活用（abuse）渐近记号更方便。渐近记号实际上应用于函数。 刻画运行时间的渐近记号应当有所区别，从而理解所指的是哪个运行时间。 $\\Theta$ 记号：给出函数的渐近上界和下界。 $O$ 记号：给出函数的渐近上界。 $\\Omega$ 记号：给出函数的渐近下界。 ","date":"2021-04-03","objectID":"/clrs-chap3/:1:0","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"$\\Theta$ 记号 对于一个给定的函数 $g(n)$，用 $\\Theta(g(n))$ 表示以下 函数的集合： $$ \\begin{aligned} \\Theta(g(n)) = \\{f(n)：存在正常量 \\ c_1, c_2\\ 和 \\ n_0\\ 使得对所有的 \\ n\\geqslant n_{0}\\ 有 \\\\ 0\\leqslant c_{1}g(n)\\leqslant f(n)\\leqslant c_{2}g(n)\\}. \\end{aligned} $$ 因为 $\\Theta(g(n))$ 是集合，而 $f(n)$ 属于 $\\Theta(g(n))$，所以可以记为 $f(n) \\in \\Theta(g(n))$，然后用更一般的方式记为 $f(n) = \\Theta(g(n))$。 若对所有 $n\\geqslant n_0$，$f(n)$ 的值在 $c_1g(n)$ 与 $c_2g(n)$ 之间，即 $f(n)$ 等于 $g(n)$ 与一个常量因子的积，则称 $g(n)$ 是 $f(n)$ 的一个渐近紧确界（asymptotically tight bound）。 $\\Theta(g(n))$ 的定义要求每个成员 $f(n) \\in \\Theta(g(n))$ 都是渐近非负的（asymptotically nonnegative），即当 $n$ 足够大时，$f(n)$ 是非负的。因此，$g(n)$ 也必须是渐近非负的。可以进一步假设渐近记号中所有函数都是渐近非负的。 类似地，渐近正函数（asymptotically positive function）表示对所有足够大的 $n$，$f(n)$ 都为正数。 在确定渐近确界时，渐近正函数可以忽略低阶项和最高阶项的系数。因为当 $n$ 很大时，低阶项对运行时间的影响远低于最高阶项，而最高阶项的系数则只影响常量因子 $c_1$ 和 $c_2$。 $\\Theta(1)$ 用来表示一个常量或关于某个变量的一个常量函数。 ","date":"2021-04-03","objectID":"/clrs-chap3/:1:1","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"$O$ 记号 $O$ 记号给出函数的渐近上界。$O(g(n))$ 的定义： $$ O(g(n)) = \\{f(n)：存在正常量 \\ c\\ 和 \\ n_0\\ 使得对所有的 \\ n\\geqslant n_{0}\\ 有 \\\\ 0\\leqslant f(n)\\leqslant cg(n)\\}. $$ 注意 $f(n) = \\Theta(g(n))$ 蕴涵 $f(n) = O(g(n))$，因为 $\\Theta(n) \\subseteq O(n)$。 当我们说「运行时间为 $O(n^2)$ 」时，意思是存在一个 $O(n^2)$ 的函数 $f(n)$，使得对于 $n$ 的任意值，不管选择什么特定的规模为 $n$ 的输入，其运行时间的上界都是 $f(n)$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:1:2","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"$\\Omega$ 记号 $\\Omega$ 记号给出函数的渐近下界。$\\Omega(g(n))$ 的定义： $$ \\Omega(g(n)) = \\{f(n)：存在正常量 \\ c 和 \\ n_0 使得对所有的 \\ n\\geqslant n_{0}\\ 有 \\\\ 0\\leqslant cg(n)\\leqslant f(n)\\}. $$ ","date":"2021-04-03","objectID":"/clrs-chap3/:1:3","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"定理 3.1 通过渐近记号的定义，可以证明以下定理： 对于任意两个函数 $f(n)$ 和 $g(n)$，当且仅当 $f(n) = O(g(n))$ 和 $f(n) = \\Omega(g(n))$ 成立时，有 $f(n) = \\Theta(g(n))$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:1:4","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"等式和不等式中的渐近记号 这一节解释等式和不等式中使用的渐近记号的含义。 $n = O(n^2)$：渐近记号独立出现在等式右边，则等于符号表示元素属于集合，即 $n \\in O(n^2)$。 $2n^2 + 3n + 1 = 2n^2 + \\Theta(n)$：更一般地，将公式中的渐近记号解释为匿名函数。本例中的 $f(n)$ 是集合 $\\Theta(n)$ 中的某个函数。像这样使用渐近记号可以消除无关紧要的细节和杂乱的部分。 一个表达式中匿名函数的数量可以理解为渐近记号出现的次数，如 $\\displaystyle\\sum_{i = 1}^{n} O(i)$ 只有一个关于 $i$ 的匿名函数。 如果渐近记号出现在左边，规则是无论怎样选择等式左边的匿名函数，总有一种方法来选择等式右边的匿名函数使等式成立。换句话说，等式右边比左边提供的细节更粗糙。这个规则可以用来解释下面的例子。 $2n^2 + \\Theta(n) = \\Theta(n^2)$：对任意 $f(n) \\in \\Theta(n)$，存在 $g(n) \\in \\Theta(n^2)$ 使得 $2n^2 + f(n) = g(n)$ 对所有 $n$ 成立。 根据后面两个例子可得： $$ \\begin{aligned} 2n^2 + 3n + 1 \u0026 = 2n^2 + \\Theta(n) \\\\ \u0026 = \\Theta(n^2). \\end{aligned} $$ ","date":"2021-04-03","objectID":"/clrs-chap3/:1:5","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"$o$ 记号 $O$ 记号提供的上界可能不是渐近紧确的，如界限 $2n^2 = O(n^2)$ 是渐近紧确的，$2n = O(n^2)$ 是非渐近紧确的。 $o$ 记号表示非渐近紧确上界： $$ o(g(n)) = \\{f(n)：对任意正常量 \\ c\u003e0，存在常量 \\ n_0\\ 使得对所有的 \\ n\\geqslant n_{0}\\ 有 \\\\ 0\\leqslant f(n)\u003c cg(n)\\}. $$ 如 $2n = o(n^2)$，$2n^2 \\ne o(n^2)$。 $O$ 记号和 $o$ 记号的主要区别是界对某个常量 $c \u003e 0$ 还是对所有常量 $c \u003e 0$ 成立。 当 $n$ 趋于无穷时，$f(n)$ 相对于 $g(n)$ 变得无关紧要，即： $$ \\lim_{n\\to \\infty}\\frac{f(n)}{g(n)} = 0 $$ ","date":"2021-04-03","objectID":"/clrs-chap3/:1:6","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"$\\omega$ 记号 $\\omega$ 记号表示非渐近紧确下界： $$ \\omega(g(n)) = \\{f(n)：对任意正常量 \\ c\u003e0，存在常量 \\ n_0 使得对所有的 \\ n\\geqslant n_{0}\\ 有 \\\\ 0\\leqslant cg(n)\u003c f(n)\\}. $$ 如 $\\cfrac{n^2}{2} = \\omega(n)$，$\\cfrac{n^2}{2} \\ne \\omega(n^2)$。 当 $n$ 趋于无穷时，有： $$ \\lim_{n\\to \\infty} \\frac{f(n)}{g(n)} = \\infty $$ ","date":"2021-04-03","objectID":"/clrs-chap3/:1:7","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"函数比较 假设 $f(n)$ 和 $g(n)$ 是渐近正函数，实数的许多关系性质也可以应用到渐近比较： 传递性：$f(n) = \\Theta(g(n))$ 且 $g(n) = \\Theta(h(n))$ 蕴涵 $f(n) = \\Theta(h(n))$。对五种记号都成立。 自反性：$f(n) = \\Theta(f(n))$。$f(n) = O(f(n))$。$f(n) = \\Omega(f(n))$。 对称性：$f(n) = \\Theta(g(n))$ 当且仅当 $g(n) = \\Theta(f(n))$。 转置对称性：$f(n) = O(n)$ 当且仅当 $g(n) = \\Omega(f(n))$。$f(n) = o(n)$ 当且仅当 $g(n) = \\omega(f(n))$。 $f(n)$ 和 $g(n)$ 的渐近比较与实数 $a$ 和 $b$ 的比较可以相类比： $f(n) = O(g(n))$ 类似于 $a\\leqslant b$； $f(n) = \\Omega(g(n))$ 类似于 $a\\geqslant b$； $f(n) = \\Theta(g(n))$ 类似于 $a = b$； $f(n) = o(g(n))$ 类似于 $a \u003c b$； $f(n) = \\omega(g(n))$ 类似于 $a \u003e b$。 若 $f(n) = o(g(n))$，则称 $f(n)$ 渐近小于 $g(n)$；若 $f(n) = \\omega(g(n))$，则称 $f(n)$ 渐近大于 $g(n)$。 渐近记号不满足实数的三分性（trichotomy）。三分性指的是对任意两个实数 $a$ 和 $b$，大于、等于和小于三种关系恰有一种必须成立。不是所有的函数都可以进行渐近比较。 ","date":"2021-04-03","objectID":"/clrs-chap3/:1:8","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"标准记号与常用函数 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:0","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"单调性 若 $m \\leqslant n$ 蕴涵 $f(m) \\leqslant f(n)$，则称函数 $f(n)$ 是单调递增的。单调递减同理。 若 $m \u003c n$ 蕴涵 $f(m) \u003c f(n)$，则称函数 $f(n)$ 是严格递增的。严格递减同理。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:1","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"向下取整和向上取整 $\\lfloor x \\rfloor$ 表示小于等于 $x$ 的最大整数。 $\\lceil x \\rceil$ 表示大于等于 $x$ 的最小整数。 对所有实数 $x$ 有 $x - 1 \u003c \\lfloor x \\rfloor \\leqslant x \\leqslant \\lceil x \\rceil \u003c x + 1$。 对任意整数 $n$ 有 $\\lceil n / 2 \\rceil + \\lfloor n / 2 \\rfloor = n$。 对任意实数 $x \\geqslant 0$ 和整数 $a,b\u003e0$，有： $$ \\begin{aligned} \\biggl\\lfloor\\frac{\\lfloor x / a \\rfloor}{b}\\biggr\\rfloor \u0026 = \\biggl\\lfloor\\frac{x}{ab}\\biggr\\rfloor, \\\\ \\biggl\\lceil\\frac{\\lceil x / a \\rceil}{b}\\biggr\\rceil \u0026 = \\biggl\\lceil\\frac{x}{ab}\\biggr\\rceil, \\\\ \\biggl\\lceil\\frac ab \\biggr\\rceil \u0026 \\leqslant \\frac{a + (b - 1)}{b}, \\\\ \\biggl\\lfloor\\frac ab \\biggr\\rfloor \u0026 \\geqslant \\frac{a - (b - 1)}{b}. \\end{aligned} $$ 两个取整函数都是单调递增的。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:2","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"模运算 对任意整数 $a$ 和任意正整数 $n$，$a \\mod n = a - n \\lfloor a / n \\rfloor$。结果有 $0 \\leqslant a \\mod n \u003c n$。 若 $(a \\mod n) = (b \\mod n)$，则记 $a \\equiv b(\\mod n)$，称模 $n$ 时 $a$ 等价于 $b$。等价地，$a \\equiv b(\\mod n)$ 当且仅当 $n$ 是 $b - a$ 的一个因子。 若模 $n$ 时 $a$ 不等价于 $b$，记 $a \\not\\equiv b(\\mod n)$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:3","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"多项式 给定一个非负整数 $d$，$n$ 的 $d$ 次多项式 $p(n) = \\displaystyle\\sum_{i = 0}^{d} a_{i}n^{i}$。 其中常量 $a_0,a_1,\\dots,a_d$ 是多项式的系数且 $a_d \\ne 0$。 一个多项式为渐近正的当且仅当 $a_d \u003e 0$。对于一个 $d$ 次渐近正的多项式 $p(n)$，有 $p(n) = \\Theta(n^d)$。 对任意实常量 $a \\geqslant 0$，函数 $n^a$ 单调递增；$a \\leqslant 0$，$n^a$ 单调递减。 若对某个常量 $k$，有 $f(n) = O(n^k)$，则称函数 $f(n)$ 是多项式有界的。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:4","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"指数 对所有实数 $a \u003e 0$、$m$ 和 $n$，有以下恒等式： $$ \\begin{aligned} a^0 \u0026= 1, \\\\ a^1 \u0026= a, \\\\ a^{-1} \u0026= 1 / a, \\\\ (a^m)^n \u0026= a^{mn}, \\\\ (a^m)^n \u0026= (a^n)^m, \\\\ a^{m}a^{n} \u0026= a^{m + n}. \\end{aligned} $$ 对所有 $n$ 和 $a \\geqslant 1$，函数 $a^n$ 关于 $n$ 单调递增。约定 $0^0 = 1$。 对所有使 $a \u003e 1$ 的实常量 $a$ 和 $b$，有 $\\displaystyle\\lim_{n \\to \\infty}\\cfrac{n^b}{a^n} = 0$。可得 $n^b = o(a^n)$。 $e$ 表示自然对数的底，对所有实数 $x$，有： $$ e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots = \\sum_{i = 0}^{\\infty}\\frac{x^i}{i!} $$ 对所有实数 $x$，有 $e^x \\geqslant 1 + x$。仅当 $x = 0$ 时不等式的等号成立。 当 $|x| \\leqslant 1$ 时，有近似估计 $1 + x \\leqslant e^x \\leqslant 1 + x + x^2$。 对所有 $x$，有 $\\displaystyle\\lim_{n \\to\\infty}\\left(1 + \\frac{x}{n}\\right)^n = e^x$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:5","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"对数 记： $$ \\begin{aligned} \\lg n \u0026 = \\log_{2}n, \\\\ \\ln n \u0026 = \\log_{e}n, \\\\ \\lg^k n \u0026 = (\\lg n)^k, \\\\ \\lg\\lg n \u0026 = \\lg(\\lg n). \\end{aligned} $$ 如果常量 $b \u003e 1$，则对 $n \u003e 0$，函数 $\\log_{b}n$ 是严格递增的。 对所有实数 $n$ 和大于零的实数 $a,b,c$，且作为底时不为 1，有 $$ \\begin{aligned} a \u0026 = b^{\\log_{b}a}, \\\\ \\log_{c}(ab) \u0026 = \\log_{c}a + \\log_{c}b, \\\\ \\log_{b}a^n \u0026 = n\\log_{b}a, \\\\ \\log_{b}a \u0026 = \\frac{\\log_{c}a}{\\log_{c}b}, \\\\ \\log_{b}(1 / a) \u0026 = -\\log_{b}a, \\\\ \\log_{b}a \u0026 = \\frac{1}{\\log_{a}b}, \\\\ a^{\\log_{b}c} \u0026 = c^{\\log_{b}a}. \\end{aligned} $$ 当 $|x| \u003c 1$ 时，$\\ln(1 + x)$ 的一种简单级数展开： $$ \\ln(1 + x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} + \\frac{x^5}{5} - \\cdots $$ 对 $x \u003e -1$，有 $\\cfrac{x}{1 + x} \\leqslant \\ln(1 + x) \\leqslant x$，仅当 $x = 0$ 时等式成立。 若对某个常量 $k$，$f(n) = O(\\lg^{k}n)$，则称函数 $f(n)$ 是多对数有界的。 对于 $\\displaystyle\\lim_{n \\to \\infty}\\cfrac{n^b}{a^n} = 0$，令 $\\lg n$ 等于 $n$，$2^a$ 等于 $a$，有 $$ \\lim_{n \\to\\infty}\\frac{\\lg^{b}n}{(2^a)^{\\lg n}} = \\lim_{n \\to\\infty}\\frac{\\lg^{b}n}{n^a} = 0 $$ 可得对于任意常量 $a \u003e 0$， 有 $\\lg^{b}n = o(n^a)$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:6","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"阶乘 阶乘 $n!$ 定义为对整数 $n \\geqslant 0$，有： $$ n! = \\begin{cases} 1 \u0026 n = 0, \\\\ n \\cdot (n - 1)! \u0026 n \u003e 0. \\end{cases} $$ 阶乘函数的一个弱上界是 $n! \\leqslant n^n$。 斯特林（Stirling）近似公式： $$ n! = \\sqrt{2\\pi n}\\left(\\cfrac{n}{e}\\right)^n\\left(1 + \\Theta\\left(\\cfrac{1}{n}\\right)\\right) $$ 可以利用斯特林公式证明：$n! = o(n^n)$，$n! = \\omega(2^n)$，$\\lg(n!) = \\Theta(n\\lg n)$。 对于 $n \\geqslant 1$，有 $n! = \\sqrt{2\\pi n}\\left(\\cfrac{n}{e}\\right)^n e^{\\alpha_n}$，其中 $\\cfrac{1}{12n + 1} \u003c \\alpha_n \u003c \\cfrac{1}{12n}$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:7","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"多重函数 $f^{(i)}(n)$ 表示函数 $f(n)$ 重复 $i$ 次作用于一个初值 $n$ 上。 假设 $f(n)$ 为实数集上的一个函数，对非负整数 $n$ 有： $$ f^{(i)}(n) \\begin{cases} n \u0026 i = 0, \\\\ f\\left(f^{(i - 1)}(n)\\right) \u0026 i \u003e 0. \\end{cases} $$ ","date":"2021-04-03","objectID":"/clrs-chap3/:2:8","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"多重对数函数 $\\lg^{*}n$ 表示多重对数。因为非正数的对数无定义，所以只有在 $\\lg^{(i - 1)}n \u003e 0$ 时 $\\lg^{i}n$ 才有定义。 多重对数函数的定义为 $\\lg^{*}n = \\min{i \\geqslant 0: \\lg^{(i)}n \\leqslant 1}$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:9","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"斐波那契数 斐波那契数的定义： $$ \\begin{aligned} F_0 \u0026 = 0, \\\\ F_1 \u0026 = 1, \\\\ F_i \u0026 = F_{i - 1} + F_{i - 2}\\quad i \\geqslant 2. \\end{aligned} $$ 黄金分割率 $\\phi$ 及其共轭数 $\\hat\\phi$ 是方程 $x^2 = x + 1$ 的两个根。 $$ \\begin{aligned} \\phi \u0026 = \\frac{1 + \\sqrt5}{2} = 1.61803\\cdots, \\\\ \\hat\\phi \u0026 = \\frac{1 - \\sqrt5}{2} = 0.61803\\cdots. \\end{aligned} $$ 特别地，有 $F_i = \\cfrac{\\phi^i - \\hat\\phi^i}{\\sqrt5}$。 因为 $|\\hat\\phi| \u003c 1$，有 $\\cfrac{|\\hat\\phi^i|}{\\sqrt5} \u003c \\cfrac{1}{\\sqrt5} \u003c \\cfrac{1}{2}$，其中蕴涵着 $F_i = \\biggl\\lfloor\\cfrac{\\phi^i}{\\sqrt5} + \\cfrac{1}{2}\\biggr\\rfloor$。 ","date":"2021-04-03","objectID":"/clrs-chap3/:2:10","tags":["CLRS"],"title":"算法导论 Chap3：函数的增长","uri":"/clrs-chap3/"},{"categories":["Algorithm"],"content":"2.1 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:1:0","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.1-1 略。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:1:1","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.1-2 for j = 2 to A.length key = A[j] i = j - 1 while i \u003e 0 and A[i] \u003c key A[i + 1] = A[i] i = i - 1 A[i + 1] = key 修改成 A[i] \u003c key 即可。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:1:2","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.1-3 for i = 1 to A.length if A[i] == v return i return NIL 循环不变式：每次 $for$ 循环开始迭代时，子数组 $A[1..i-1]$ 由均不等于 $v$ 的元素组成。 初始化：证明循环不变式在循环开始前为真。循环开始前 $i=1$。子数组为空，因此为真。 保持：证明循环不变式在循环的下一次迭代时仍为真。将 $A[i]$ 和 $v$ 相比较，如果二者相同，就返回 $i$；否则循环继续下一次迭代。每次循环的迭代结束时，子数组 $A[1..i]$ 中不包含 $v$，因此循环不变式仍为真。在循环下一次迭代中递增 $i$ 的值将维持循环不变式。 终止：证明循环不变式在循环终止时仍为真。让循环结束的条件为 $i\u003eA.length=n$，确切地说此时必定有 $i=n+1$。将 $i$ 替换为 $n+1$，则子数组 $A[1..n]$ 由均不等于 $v$ 的元素组成，因此返回 $\\text{NIL}$。观察到子数组 $A[1..n]$ 等于原来的整个数组，可以得出结论原数组中不包含等于 $v$ 的元素。故算法正确。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:1:3","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.1-4 因为涉及到进位，需要考虑如何计算相加后 $C$ 中的数字。使用一个变量来保存 $A$ 和 $B$ 每个位相加时的进位。使用模运算可以得到相加后的余数，使用除法求进位的数字。 举个例子： $A = [1, 0, 0, 1]$，$B = [1, 1, 0, 1]$，则 $C = [1, 0, 1, 1, 0]$。 形式化描述： 输入: $A$ 和 $B$ 都是二进制数字的数组，长度均为 $n$​。 $\\forall i\\in{1\\dots n}:\\ A[i],B[i]\\in{0,1}$. 输出: 二进制数字的数组 $C$，长度为 $n+1$。 $\\forall i\\in{1\\dots n+1}:\\ C[i]\\in{0,1}$: $$ \\sum_{i=1}^{n+1}C[i]*2^{i-1}=\\sum_{j=1}^{n}A[j]*2^{j-1}+\\sum_{k=1}^{n}B[k]*2^{k-1} $$ let C[A.length + 1] be new array carry = 0 for i = A.length downto 1 // remainder C[i + 1] = (A[i] + B[i] + carry) % 2 // quotient carry = (A[i] + B[i] + carry) / 2 C[1] = carry return C ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:1:4","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.2 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:2:0","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.2-1 $\\Theta(n^3)$。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:2:1","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.2-2 for i = 1 to A.length - 1 min = A[i] for j = i + 1 to A.length if A[i] \u003e A[j] min = A[j] swap(A[i], min) 1、循环不变式：在 $for$ 循环的开始，子数组 $A[1..i-1]$ 由数组 $A$ 中已排序的最小的 $i-1$ 个元素组成。 初始化：循环开始前 $i=1$，子数组为空，因此为真。 保持：循环每次迭代结束时，将最小值放到 $A[i]$ 的位置，子数组 $A[1..i-1]$ 中的元素都比 $A[i]$ 小，且已排序，因此循环不变式为真。在循环下一次迭代中递增 $i$ 的值将维持循环不变式。 终止：循环结束的条件为 $i=A.length=n$。此时子数组 $A[1..n-1]$ 由原来数组 $A[1..n]$ 的 $n-1$ 个元素组成，且已排序。而剩下的元素则保证不小于子数组中的元素，因此整个数组都是有序的。故算法正确。 2、前 $n-1$ 个元素排序完成后，子数组 $A[1..n-1]$ 由数组 $A$ 中已排序的最小的 $n-1$ 个元素组成，因此第 $n$ 个元素必定是数组中最大的元素，此时它已经在正确的位置，无需再排序。 3、选择排序最好的情况（数组已排序）和最坏的情况（数组逆序）都需要将外循环和内循环的每一条语句执行一遍，所以都需要 $\\Theta(n^2)$ 时间。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:2:2","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.2-3 1、分析在数组 $A[a_1,a_2,\\dots,a_n]$ 中进行线性查找的平均情况：第 1 个元素需要查找 1 个元素，第 2 个元素查找 2 个，以此类推，第 n 个元素查找 n 个。总共查找 n 次，因此平均个数为 $\\cfrac{1+2+\\dots+n}n=\\cfrac{n+1}2$ 个。 2、最坏情况是查找到第 $n$ 个元素。 3、平均情况和最坏情况的运行时间都是 $\\Theta(n)$。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:2:3","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.2-4 没看懂问题，看了下官方的答案，应该是通过添加一个特殊的情况，如果输入符合这个特例，则输出预先计算的结果，这样就可以得到最好情况的运行时间了。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:2:4","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:0","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-1 略。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:1","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-2 n1 = q - p + 1 n2 = r - q let L[1..n1] and R[1..n2] be new arrays for i = 1 to n1 L[i] = A[p + i - 1] for j = 1 to n2 R[j] = A[q + j] i = 1 j = 1 k = p while i \u003c n1 and j \u003c n2 if L[i] \u003c R[j] A[k] = L[i] i = i + 1 else A[k] = R[j] j = j + 1 k = k + 1 if j == n2 A[k..r] = L[i..n1] 第 19 行只需要判断 j 是否等于右子数组的长度，因为左子数组的长度是大于等于右子数组的。如果右子数组已遍历完，则表示左子数组中剩余的元素都大于循环开始时右子数组的任意元素，并且已排序。此时只需要将左子数组中的剩余元素复制到合并数组中即可。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:2","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-3 以下用 $\\lg n$ 表示 $\\log_2 n$。 基本情况：当 $n=2$ 时，$T(n)=2 \\lg 2 = 2$。 设 $n=2^k$，$T(n)=n\\lg n=2^k\\lg 2^k=2^k\\cdot k$。 对于 $n=2^{k+1}$， $$ \\begin{aligned} T(n) \u0026 = 2 \\cdot T(2^{k + 1}/2)+2^{k + 1} \\\\ \u0026 = 2 \\cdot T(2^k) + 2^{k + 1} \\\\ \u0026 = 2 \\cdot 2^k + 2^{k + 1} \\\\ \u0026 = 2^{k + 1}\\cdot (k + 1) \\\\ \u0026 = 2^{k + 1}\\cdot \\lg 2^{k + 1} \\\\ \u0026 = n\\lg n. \\end{aligned} $$ 故 $T(n)=n\\lg n$，其中 $n$ 是 2 的整数幂。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:3","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-4 最坏情况下将 $A[n]$ 插入到已排序数组 $A[1..n - 1]$ 需要的时间为 $\\Theta(n)$，因此： $$ T(n) = \\begin{cases} \\Theta(1) \u0026\\ \\text{if}\\ n = 1, \\\\ T(n - 1) + \\Theta(n) \u0026\\ \\text{if}\\ n\u003e1. \\end{cases} $$ 递推式的结果是 $\\Theta(n^2)$。 递归式插入排序的关键操作是「合并」步骤中将 $A[n]$ 插入到已排序数组 $A[1..n - 1]$ 中。这一过程用辅助函数 insert(A, n) 表示。 只要向排序主函数 insertion_sort_recursive(A, n) 传递的数组 $A$ 长度大于 0 ，就可以递归调用它自身，然后调用 insert(A, n) 合并。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:4","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-5 迭代式：ITERATIVE-BINARY-SEARCH(A, v, lo, hi) while lo \u003c= hi mid = floor((lo + hi) / 2) if A[mid] == v return mid else if A[mid] lo = mid + 1 else hi = mid - 1 return NIL 递归式：RECURSIVE-BINARY-SEARCH(A, v, lo, hi) if lo \u003e hi return NIL mid = floor((lo + hi) / 2) if A[mid] == v return mid else if A[mid] \u003c v return RECURSIVE-BINARY-SEARCH(A, v, mi + 1, hi) else return RECURSIVE-BINARY-SEARCH(A, v, lo, mid - 1) 算法每次都将 $v$ 和数组中点元素相比较，从而将搜索范围减半。 递归式： $$ T(n) = \\begin{cases} \\Theta (1) \u0026 \\text{if}\\ n = 1, \\\\ T(n/2)+\\Theta (1) \u0026 \\text{if}\\ n \u003e 1. \\end{cases} $$ 递归式的结果是 $\\Theta(\\lg n)$。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:5","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-6 不能。查找虽然是 $\\Theta(\\lg n)$，但移动元素仍然是 $\\Theta(n)$。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:6","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2.3-7 $\\star$ 首先对 $S$ 排序，需要 $\\Theta(n\\lg n)$ 时间。 然后对于 $S$ 中的元素 $e_i$，$i = 1,\\dots,n$，用二分查找在 $A[i + 1..n]$ 中查找 $e_j = x - e_i$，需要 $\\Theta(\\lg n)$ 时间。 如果找到 $e_j$，返回 $j$ 的值；否则进行下一次迭代。 算法总共所需时间 $\\Theta(n\\lg n) + n\\cdot \\Theta(\\lg n)=\\Theta(n\\lg n)$。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:3:7","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"思考题 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:4:0","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2-1 a. 对长度为 $k$ 的子表使用插入排序的最坏情况需要 $\\Theta(k^2)$ 时间，因此对 $n / k$ 个长度为 $k$ 的子表使用插入排序的最坏情况需要 $n / k \\cdot \\Theta(k^2) = \\Theta(nk)$ 时间。 b. 因为有 $n / k$ 个子表，每次将两个子表合并，需要合并的次数是 $\\lg (n / k)$；每次合并最坏时间为 $\\Theta(n)$，所以将所有子表合并的最坏情况是 $\\Theta(n \\lg (n / k))$。 c. 根据题意有 $\\Theta (nk + n \\lg (n / k)) \\leqslant \\Theta(n \\lg n)$。因此 $nk$ 对整体时间的影响应该小于 $ n\\lg n$，$k$ 的最大值为 $\\lg n$。 d. 选择让插入排序比归并排序快时的 $k$ 的值。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:4:1","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2-2 a. $A’$ 中的元素都是 $A$ 中的元素，不过已排序。 b. 循环不变式：第 2-4 行的 for 循环每次迭代开始时，子数组 $A[j..n]$ 由原来在 $A[j..n]$ 中的元素组成，但顺序可能发生了变化，且首元素 $A[j]$ 是子数组中最小的元素。 初始化：循环第一次迭代开始时，子数组仅包含单个元素 $A[n]$，因此是有序的。 保持 ：每次迭代都将 $A[j]$ 和 $A[j - 1]$ 比较，并让较小的元素交换到下标较小的位置。迭代完成后，子数组 $A[j..n]$ 递增一个元素，且首元素是子数组中最小的元素。 终止：导致 $for$ 循环终止的条件是 $j = i$。在循环不变式中用 $i$ 代替 $j$，有：子数组 $A[i..n]$ 由原来在 $A[i..n]$ 中的元素组成，$A[i]$ 是子数组中最小的元素。 c. 循环不变式：第 1-4 行的 $for$ 循环每次迭代开始时，子数组 $A[1..i - 1]$ 由数组 $A[1..n]$ 中最小的 $i - 1$ 个元素组成，且已排序。子数组 $A[i..n]$ 由 $A[1..n]$ 中剩余的元素组成。 初始化：循环第一次迭代开始时，子数组 $A[1..i - 1]$ 是空数组。 保持：内循环每次迭代后，$A[i]$ 都会成为子数组 $A[i..n]$ 中最小的元素。在下次外循环开始前，$A[1..i - 1]$ 由比 $A[i..n]$ 中更小的元素组成，且已排序。外循环迭代后，$A[1..i]$ 将包含比 $A[i + 1..n]$ 更小的元素，且已排序。 终止：当 $i = A.length$ 时，循环终止。此时 $A[1..n]$ 将由所有已排序的元素组成。 d. 第 $i$ 次外循环将执行 $n - i$ 次内循环，所以最坏情况运行时间是 $\\Theta(n^2)$。理论上运行时间和插入排序一样，但由于多次交换操作，实际会更慢。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:4:2","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2-3 a. $\\Theta(n)$。 b. NAIVE-POLYNOMIAL-EVALUATION： y = 0 for i = 0 to n m = 1 for k = 1 to i m = m * x y = y + a[i] * m 运行时间是 $\\Theta(n^2)$，比 Horner 规则慢许多。 c. 初始化：一开始没有项，$y = 0$。 保持：在第 $i$ 次迭代，有 $$ \\begin{aligned} y \u0026 = a_i + x \\sum_{k = 0}^{n - (i + 1)} a_{k + i + 1} x^k \\\\ \u0026 = a_i x^0 + \\sum_{k = 0}^{n - i - 1} a_{k + i + 1} x^{k + 1} \\\\ \u0026 = a_i x^0 + \\sum_{k = 1}^{n - i} a_{k + i} x^k \\\\ \u0026 = \\sum_{k = 0}^{n - i} a_{k + i} x^k. \\end{aligned} $$ 终止：当 $i = -1$ 时终止，将 $i = 0$ 代入，得 $\\displaystyle y = \\sum_{k = 0}^{n - i - 1} a_{k + i + 1} x^k = \\sum_{k = 0}^n a_k x^k$。 d. 在 c 中证明了循环不变式，循环不变式的和等于给定系数的多项式。 ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:4:3","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"2-4 a. $(1, 5)$，$(2, 5)$，$(3, 4)$，$(3, 5)$，$(4, 5)$。 b. 集合 ${1, 2, \\ldots, n}$ 的逆序构成的数组 $\\langle n, n - 1, \\cdots, 1\\rangle$ 具有最多的逆序对。逆序对的个数为 $(n - 1) + (n - 2) + \\cdots + 1 = \\cfrac{n(n - 1)}{2}$。 c. 插入排序的运行时间正比于逆序对的数量。 d. 首先需要清楚逆序对的构成。如果对数组进行归并排序来计算逆序对，则数组的逆序对由子数组中的逆序对和跨子数组的逆序对两部分组成。实际只要计算跨子数组的逆序对，因为子数组中的逆序对可以通过递归计算它自己的两部分逆序对得到。 CROSS-INVERSION-COUNT(A, p, q, r)： n1 = q - p + 1 n2 = r - q let L[1..n1 + 1] and R[1..n2 + 1] be new arrays for i = 1 to n1 L[i] = A[p + i - 1] for j = 1 to n2 R[j] = A[q + j] L[n1 + 1] = ∞ R[n2 + 1] = ∞ i = 1 j = 1 inversions = 0 for k = p to r if L[i] \u003c= R[j] A[k] = L[i] i = i + 1 else inversions = inversions + n1 - i + 1 A[k] = R[j] j = j + 1 return inversions INVERSIONS-COUNT(A, p, r)： if p \u003c r q = floor((p + r) / 2) left = INVERSION-COUNT(A, p, q) right = INVERSION-COUNT(A, q + 1, r) inversions = CROSS-INVERSION-COUNT(A, p, q, r) + left + right return inversions ","date":"2021-04-02","objectID":"/clrs-chap2-exercises/:4:4","tags":["CLRS"],"title":"算法导论 Chap2 习题","uri":"/clrs-chap2-exercises/"},{"categories":["Algorithm"],"content":"循环不变式 当我们写完程序后，通常会编写测试来检查程序是否产生预期的结果。如果结果和预期一致，则认为程序能正常完成任务。但是有限的测试用例无法保证程序所使用的算法在其他情况下是否仍然得到正确的结果。因此我们需要证明算法的正确性。 循环不变式（loop invariant）是用于证明循环的循环体在程序执行前后都为真的谓词。需要证明循环不变式的三条性质： 初始化：循环的第一次迭代之前，循环不变式为真； 保持：如果循环的某次迭代之前不变式为真，那么下次迭代之前它仍为真； 终止：在循环终止时，不变式为我们提供了一个有用的性质，该性质有助于证明算法是正确的。 证明方法类似于数学归纳法，证明一个基本情况和一个归纳步： 基本情况：第一次迭代之前不等式成立； 归纳步：证明从一次迭代到下一次迭代，不变式仍然成立。 数学归纳法中的归纳步是无限的，而循环不变式则需要在循环结束时停止「归纳」。我们通过终止时的循环不变式来证明算法的正确性。通常与导致循环终止的条件一起使用循环不变式。 ","date":"2021-03-26","objectID":"/clrs-chap2/:1:0","tags":["CLRS","Python"],"title":"算法导论 Chap2：算法基础","uri":"/clrs-chap2/"},{"categories":["Algorithm"],"content":"插入排序 排序就是将一个序列的数按大小进行排列，得到一个新的序列，它满足每个元素都不大于相邻的前一个元素。序列从左到右增长，因此右边是「前」，左边是「后」。每次排序的数称为键（key）。 对一个序列中的数进行排序有许多种算法，首先来看插入排序。插入排序通过对序列中的数进行比较交换，将键按其大小插入到相应位置来完成排序任务。插入排序对数组中的数进行原地（in place）排序，任何时候最多有常数个数字存储在数组外。 def insertion_sort(a: list[int]) -\u003e None: for j in range(1, len(a)): key = a[j] i = j - 1 while i \u003e= 0 and a[i] \u003e key: a[i + 1] = a[i] i = i - 1 a[i + 1] = key 与 a[j] 相比，变量 key 可以让当前要插入的元素更直观。 插入排序的关键在 while 循环。while 循环在已排序的子数组 a[:j] 中从前向后寻找元素插入位置，其判断条件与 key 的大小有关： 若 key 不大于子数组的最小元素，那么即使遍历到第一个元素也不会有比它更小的了。因此当 i = -1 时停止 while 循环，在 a[0] 的位置插入 key。 若 key 大于子数组的最小元素，那就表示有元素小于它。因此当 a[i] 小于 key 时停止 while 循环，在该元素下一位置 a[i + 1] 插入 key。 ","date":"2021-03-26","objectID":"/clrs-chap2/:2:0","tags":["CLRS","Python"],"title":"算法导论 Chap2：算法基础","uri":"/clrs-chap2/"},{"categories":["Algorithm"],"content":"算法分析 对算法进行分析就是对算法所需的资源进行预测。其中最重要的度量是时间。 实现算法的程序运行在一个假想的单处理器计算模型 RAM（random-access mathine）上。我们假设 RAM 具有真实计算机常见的指令，每条指令所需时间为常量，并且仅按照顺序执行。 具有整形和浮点型数据类型，并为数据类型字长设定一个范围。 忽略内存层次的问题以简化模型。 在具体分析算法时，需要对输入规模（input size）和运行时间（running time）进行仔细地定义： 输入规模：对于如排序或计算离散傅里叶变换，用输入中的项数度量；对于如两个整数相乘，用二进制记号表示输入所需的总位数；对于图等输入，用两个数来描述输入。 运行时间：指在特定输入上执行的基本操作数或步数。定义「步」的概念使得算法尽量与机器无关。假设每次执行第 $i$ 行的代码需要常量时间 $c_i$。算法的运行时间就是每条语句的运行时间之和。 根据给定输入规模下输入的不同，算法的执行时间不同，因而存在最佳情况和最坏情况。我们最感兴趣的是最坏情况，因为： 算法的最坏情况给出了任何输入的运行时间的一个上界。 某些算法经常会出现最坏情况。 平均情况的运行时间往往与最坏情况一样差。 平均情况的运行时间依赖于概率分析。通常可假设给定规模的所有输入具有相同的可能性。如果假设不成立，则可能使用随机化算法，对随机的选择进行概率分析来生成期望的运行时间。 算法运行时间的公式往往是一个多项式。我们只考虑多项式中最高次数的项，而忽略低阶项和最高次数项的常量系数。因为算法运行时间的增长率由最高次数项决定。使用 $\\Theta$ 记号将插入排序的最坏运行时间记为 $\\Theta(n^2)$。对于足够大的输入，高效的算法具有增长量级更低的最坏运行时间。 ","date":"2021-03-26","objectID":"/clrs-chap2/:3:0","tags":["CLRS","Python"],"title":"算法导论 Chap2：算法基础","uri":"/clrs-chap2/"},{"categories":["Algorithm"],"content":"归并排序 首先定义递归（recursive）算法：算法一次或多次递归地调用自身来解决密切相关的子问题。 分治法（divide-and-conquer）：一些问题可以分成相类似的规模较小的子问题，子问题也可以继续分解为更小的子问题。像这样递归地求解子问题，然后将解合并，从而得到原问题的解。 分治法的三个步骤： 分解（Divide）：分解原问题为子问题； 解决（Conquer）：递归求解子问题，对规模足够小的子问题直接求解； 合并（Combine）：合并子问题的解，得到原问题的解。 归并排序（merge sort）的操作： 分解：将待排序的 $n$ 个元素的序列分解为两个子序列，每个都有 $n/2$ 个元素。 解决：使用归并排序递归地排序两个子序列。 合并：将两个已排序子序列合并得到完成排序的原序列。 归并排序的关键是「合并」这一步，将两个已排序的序列合并。用辅助函数 merge 表示这个过程。 def merge(a: list[int | float], p: int, q: int, r: int) -\u003e None: left = a[p : q + 1] right = a[q + 1 : r + 1] left.append(float('inf')) right.append(float('inf')) i = j = 0 for k in range(p, r + 1): if left[i] \u003c= right[j]: a[k] = left[i] i += 1 else: a[k] = right[j] j += 1 数组 a[p:r] 的子数组 a[p : q + 1] 和 a[q + 1 : r + 1] 都已经完成排序，现在需要将它们合并，使 a[p:r] 有序。其中数组下标 p、q 和 r 满足 $p\\leqslant q \u003c r$。 merge 首先将两个子数组复制到 left 和 right 数组中，然后分别添加 float('inf') 到 left 和 right 的末尾，用无限作为哨兵。然后在 for 循环中比较 left 和 right 中元素的大小，按序复制回数组 a[p:r] 中。merge 需要 $\\Theta(n)$ 时间，其中 $n = r - p + 1$，表示合并元素的总数。 现在可以将归并排序的三个步骤用函数 merge_sort 来表示了： def merge_sort(a: list[int | float], p: int, r: int) -\u003e None: if p \u003c r: q = (p + r) // 2 merge_sort(a, p, q) merge_sort(a, q + 1, r) merge(a, p, q, r) 对于子数组的首尾元素的下标，若 $p \\geqslant r$，则子数组中只有一个元素，子数组已排序，这是算法的基本情况。其余情况下需要将子数组分解为两个更小的子数组，递归调用 merge_sort 直到基本情况。根据 $p$ 和 $r$ 的奇偶情况分析可得子数组 a[p : q + 1] 包含 $\\lceil n / 2 \\rceil$ 个元素，子数组 a[q + 1 : r + 1] 包含 $\\lfloor n / 2 \\rfloor$ 个元素。 然后从基本情况开始合并，一对子数组合并为包含两个子数组所有元素的子数组，接着与类似的子数组合并为更大的子数组，以此类推，直到合并为长度为 $n$ 的数组。 算法包含对自身的递归调用时，可以用递归等式（recurrence equation）或递归式（recurrence）来描述运行时间。通过主定理可以证明归并排序的最坏情况运行时间为 $\\Theta(n\\ \\text{lg}\\ n)$。 为了方便起见，将练习 2.3-2 中未使用哨兵的实现也列出。 def merge(a: list[int], p: int, q: int, r: int) -\u003e None: left = a[p : q + 1] right = a[q + 1 : r + 1] i = j = 0 k = p while i \u003c len(left) and j \u003c len(right): if left[i] \u003c= right[j]: a[k] = left[i] i += 1 else: a[k] = right[j] j += 1 k += 1 if j == len(right): a[k : r + 1] = left[i:] def merge_sort(a: list[int], p: int, r: int) : if p \u003c r: q = (p + r) // 2 merge_sort(a, p, q) merge_sort(a, q + 1, r) merge(a, p, q, r) ","date":"2021-03-26","objectID":"/clrs-chap2/:4:0","tags":["CLRS","Python"],"title":"算法导论 Chap2：算法基础","uri":"/clrs-chap2/"},{"categories":null,"content":"这里是我记录学习总结、想法的地方。希望能留下一些有价值的东西。 ","date":"2021-02-22","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Arch + WSL2 下载 arch.zip：https://github.com/yuk7/ArchWSL/releases。 解压，执行 Arch.exe： .\\Arch.exe 成功后再次执行 Arch.exe。获取普通用户的 root 权限： echo \"%wheel ALL=(ALL) ALL\" \u003e /etc/sudoers.d/wheel 设置 root 密码： passwd 创建用户并设置密码： useradd -m -G wheel -s /bin/bash \u003cusername\u003e passwd \u003cusername\u003e 设置默认用户： exit .\\Arch.exe config --default-user \u003cusername\u003e 在 /etc/pacman.d/mirrorlist 文件找到下行并取消注释： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 修改 /etc/pacman.conf 文件： [archlinuxcn] # 清华大学 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 初始化 keyring： sudo pacman-key --init sudo pacman-key --populate sudo pacman -Syy archlinuxcn-keyring 关闭所有终端，然后重新打开 Arch 安装更新软件和包： sudo pacman -Syu sudo pacman -S zsh git clang lld rustup bat ripgrep fd starship zoxide neovim luajit gcc gdb make nodejs openssh gitui yarn 更换默认 shell 为 zsh： chsh -s /usr/bin/zsh 安装 zsh 插件： sudo pacman -S zsh-autosuggestions zsh-syntax-highlighting zsh-completions 在 .zshrc 文件添加： source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 在 zsh 中启用 starship、zoxide，将下面代码添加到 .zshrc 文件中： eval \"$(starship init zsh)\" eval \"$(zoxide init bash)\" rustup 换源，在 .zshrc 文件添加： export RUSTUP_DIST_SERVER=\"https://rsproxy.cn\" export RUSTUP_UPDATE_ROOT=\"https://rsproxy.cn/rustup\" 安装 rust： rustup install nightly 添加 rustup 组件： rustup component add rust-analyzer-preview rust-analysis miri rust-src cargo 换源： [source.crates-io] replace-with = 'rsproxy' [source.rsproxy] registry = \"https://rsproxy.cn/crates.io-index\" [registries.rsproxy] index = \"https://rsproxy.cn/crates.io-index\" [net] git-fetch-with-cli = true 配置 neovim，当前比较流行采用 packer.nvim 包管理器进行插件管理。我参考的配置。 我遇到了 telescope-fzf-native 找不到 fzf 扩展的问题。在网上搜索后找到解决方案。输入以下命令，注意 telescope-fzf-native 的安装位置可能有所不同。 cd ~/.local/share/nvim/site/pack/packer/opt/telescope-fzf-native.nvim \u0026\u0026make clean \u0026\u0026 make 另外在 wsl2 中配置的主题似乎无效，只能选择 windows terminal 的主题。 使用 ssh 连接到 GitHub。首先配置用户，然后创建一个新的密钥： git config --global user.name \"your github name\" git config --global user.email \"your github default email address\" ssh-keygen -t ed25519 -C \"your_email@example.com\" 可选的 passphase。显示 ~/.ssh/id_ed25519.pub 公钥的内容然后复制： bat ~/.ssh/id_ed25519.pub 到 https://github.com/settings/keys 点击 New SSH key，取名 archlinux-wsl2-ssh，粘贴公钥，点击 Add SSH key，输入 GitHub 密码确认。测试 SSH 连接： ssh -T git@github.com 会显示 GitHub 的公钥，和官方公布的公钥对比验证后输入 yes。 ","date":"0001-01-01","objectID":"/arch--wsl2/:0:0","tags":null,"title":"","uri":"/arch--wsl2/"}]