---
title: "Fluent Python Chap6：对象引用、可变性和垃圾回收"
date: 2021-05-12T08:43:19+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

对象和对象名称有所区别，名称不是对象，而是单独的东西。

Python 变量是标签，而非盒子。Python 变量类似于 Java 中的引用式变量，因此最好把它们理解为附加在对象上的标注。对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了。

<!--more-->

为了理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标签。

因为变量只不过是标注，所以无法阻止为对象贴上多个标注。贴的多个标注，就是别名。

对 `+=` 或 `*=` 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。

为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。

每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。`is` 运算符比较两个对象的标识；`id()` 函数返回对象标识的整数表示。

`==` 运算符比较两个对象的值（对象中保存的数据），而 `is` 比较对象的标识。

目前，最常使用 is 检查变量绑定的值是不是 `None`。

```python
x is None
x is not None
```

`is` 运算符比 `==` 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是直接比较两个整数 ID。而 `a == b` 是语法糖，等同于 `a.__eq__(b)`。继承自 object 的 `__eq__` 方法比较两个对象的 ID，结果与 `is` 一样。但是多数内置类型使用更有意义的方式覆盖了 `__eq__` 方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的结构时。

元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象的引用。如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指 `tuple` 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

## 默认做浅拷贝

复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。

```python
l1 = [3, [55, 44], (7, 8, 9)]
l2 = list(l1)
l2 == l1  # True
l2 is l1  # False
```

对列表和其他可变序列来说，还能使用简洁的 `l2 = l1[:]` 语句创建副本。

然而，构造方法或 `[:]` 做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。

有时我们需要的是深复制（即副本不共享内部对象的引用）。`copy` 模块提供的 `deepcopy` 和 `copy` 函数能为任意对象做深复制和浅复制。

## 函数参数作为引用

Python 唯一支持的参数传递模式是共享传参（call by sharing）。多数面向对象语言都采用这一模式，包括 Ruby、Smalltalk 和 Java（Java 的引用类型是这样，基本类型按值传参）。

共享传参指函数的各个形参获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。

不要使用可变类型作为参数的默认值。

如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。

## del 和垃圾回收

`del` 语句删除名称，而非对象。

在 CPython 中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁：CPython 会在对象上调用 `__del__` 方法（如果定义了），然后释放分配给对象的内存。

## 弱引用

正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但是，有时需要引用对象，而不让对象存在的时间超过所需时间。这经常用在缓存中。

弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。

使用 `weakref.ref` 实例获取 referent。如果对象存在，调用弱引用可以获取对象；否则返回 None。

`WeakValueDictionary` 类实现的是一种可变映射，里面的值是对象的弱引用。被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从 `WeakValueDictionary` 中删除。因此，`WeakValueDictionary` 经常用于缓存。

与 `WeakValueDictionary` 对应的是 `WeakKeyDictionary`，后者的键是弱引用。

基本的 `list` 和 `dict` 实例不能作为 referent，但是它们的子类可以轻松地解决这个问题。`set` 实例可以作为 referent。