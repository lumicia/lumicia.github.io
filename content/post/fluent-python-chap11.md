---
title: "Fluent Python Chap11：符合 Python 风格的对象"
date: 2021-05-20T12:45:01+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

Python 数据模型可以让自定义类型的行为像内置类型一样自然。通过鸭子类型（duck typing）只需按照预定行为实现对象所需的方法即可。

<!--more-->

## 对象表示形式

Python 提供了两种获取对象的字符串表示形式的标准方式：

- `repr()`：以便于开发者理解的方式返回对象的字符串表示形式。
- `str()`：以便于用户理解的方式返回对象的字符串表示形式。

要实现 `__repr__` 和 `__str__` 特殊方法，为 repr() 和 str() 提供支持。

为了给对象提供其他的表示形式，还会用到另外两个特殊方法：`__bytes__` 和 `__format__`。`__bytes__` 方法与 `__str__` 方法类似：`bytes()` 函数调用它获取对象的字节序列表示形式。而 `__format__` 方法会被内置的 `format()` 函数和 `str.format()` 方法调用，使用特殊的格式代码显示对象的字符串表示形式。

## 自定义向量类

对于自定义的向量类，期望的实例行为有：

- 支持`__str__`方法，将类实例的成员以用户友好的方式打印出来；
- 支持`__iter__`方法，对类实例进行元组拆包；
- 支持`__repr__`方法，将类实例以接近源码的方式打印出来；
- 支持`__eq__`方法，从而使用`==`运算符；
- 支持`__bytes__`方法，生成实例的二进制表示；
- 支持`__abs__`方法，返回实例的模；
- 支持`__bool__`方法，对模大小是否为`0`进行真假判断。

## classmethod 与 staticmethod

`classmethod` 装饰器定义操作类的方法，而不是操作实例的方法。`classmethod` 改变了调用方法的方式，类方法的第一个参数是类本身，而不是实例。`classmethod` 最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为 `cls`。

上面的向量类可以把实例转换成字节序列，同理，也应该能从字节序列转换成类实例。可以使用`array.array`中的类方法`.frombytes`，并用`classmethod`装饰器装饰。

`staticmethod` 装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。

## 格式化显示

f-string是Python3.6引入的一种新的字符串格式化方式，在`str.format()`方法的基础之上做出了一些改动。f-string比`format()`和`str.format()`更快。

f-string通过在`{}`中替换字段来格式化字符串，把各个类型的格式化方式委托给相应的`.__format__(format_spec)`方法。`format_spec`是格式说明符，即`{}`中替换字段中`:`后面的部分。

```python
>>> cny = 1/6.3674
>>> cny
0.15704997330150455
>>> f'{cny:.4f}'
'0.1570'
>>> f'1 CNY = {cny:0.2f} USD'
'1 CNY = 0.16 USD'
```

格式说明符使用的表示法称为格式规范微语言。格式规范微语言为一些内置类型提供了专用的表示代码。比如，`b` 和 `x` 分别表示二进制和
十六进制的 `int` 类型，`f` 表示小数形式的 `float` 类型，而 `%` 表示百分数形式。

```python
>>> f'{42:b}'
'101010'
>>> f'{2/3:.1%}'
'66.7%'
```

格式规范微语言是可扩展的，因为各个类可以自行决定如何解释 `format_spec` 参数。例如，`datetime` 模块中的类，它们的 `__format__` 方法使用的格式代码与 `strftime()` 函数一样。

```python
>>> from datetime import datetime
>>> now = datetime.now()
>>> f"{now:%H:%M:%S}"
'13:53:24'
>>> f"It's now {now:%I:%M %p}"
"It's now 01:53 PM"
```

如果类没有定义 `__format__` 方法，从 `object` 继承的方法会返回 `str(my_object)`。我们为向量类定义了`__str__`方法，因此可以使用f-string。然而，如果传入格式说明符，`object.__format__` 方法会抛出 `TypeError`。可以通过实现自己的微语言来解决这个问题。

## 可散列的向量类

为了将向量实例放入`set`中，需要把向量类实例变成可散列的。因此必须使用`__hash__`方法（还需要 `__eq__` 方法，前面已经实现了）。此外，还要让向量不可变。通过使用两个前导下划线把属性标记为私有的，把向量设为只读特性。

`__hash__`方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（`__eq__` 方法也要使用），因为相等的对象应该具有相同的散列值。最好使用异或来计算各分量的散列值。

如果定义的类型有标量数值，可能还要实现 `__int__` 和 `__float__` 方法（分别被 `int()` 和`float()` 构造函数调用），以便在某些情况下用于强制转换类型。此外，还有用于支持内置的 `complex()` 构造函数的 `__complex__` 方法。

## 使用 `__slots__` 类属性节省空间

如果要处理数百万个属性不多的实例，通过 `__slots__` 类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不用字典。

继承自超类的 `__slots__` 属性没有效果。Python 只会使用各个类中定义的`__slots__` 属性。

定义 `__slots__` 的方式是，创建一个类属性，使用 `__slots__` 这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。使用元组定义的 `__slots__` 中所含的信息不会变化。

实例只能拥有 `__slots__` 中列出的属性，除非把 `__dict__` 加入 `__slots__` 中（这样做就失去了节省内存的功效）。

为了让对象支持弱引用，必须有`__weakref__`这个属性。用户定义的类中默认就有 `__weakref__` 属性。可是，如果类中定义了 `__slots__` 属性，而且想把实例作为弱引用的目标，那么要把 `__weakref__`
添加到 `__slots__` 中。

处理列表数据时 `__slots__` 属性最有用，例如模式固定的数据库记录，以及特大型数据集。

## 覆盖类属性

Python 有个很独特的特性：类属性可用于为实例属性提供默认值。

但是，如果为不存在的实例属性赋值，会新建实例属性，覆盖同名类属性。借助这一特性，可以为各个实例的属性定制不同的值。

类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。
