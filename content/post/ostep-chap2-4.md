---
title: "Ostep Chap2 04：多级反馈队列调度"
date: 2021-09-13T17:32:46+08:00
categories: ["OS"]
tags: ["OSTEP"]
draft: false
---

多级反馈队列（Multi-level Feedback Queue，MLFQ）调度器想要解决上一节中遇到的困难：在不知道任务具体运行时间的情况下，减少周转时间，同时减少交互式任务的响应时间。

规则 1：首先，MLFQ 拥有一些互不相同的队列，每个队列都赋予不同的优先级。在任何给定的时间，一个准备好要运行的任务只处于其中一个队列。MLFQ 用优先级来决定在给定时间运行哪个任务：高优先级的任务先运行，即任务处于高等级的队列。

规则 2：其次，如果一个队列上有多个任务，则这些任务的优先级相同。此时使用 RR 算法调度这些任务。

现在 MLFQ 有了两个基本规则，接下来要决定任务的优先级。每个任务的优先级不是固定的，通过观察其行为，MLFQ 动态修改任务的优先级。通过观察任务的历史行为是 IO 密集还是 CPU 密集的，MLFQ 可以预测它的未来行为是怎样的。

规则 3：当一个任务进入系统时，先分配最高优先级的队列。

规则 4a：如果任务在一个时间片内都在运行，就把优先级降低一个级别。

规则 4b：如果任务在时间片结束之前就让出了 CPU，维持它的优先级不变。

现在的 MLFQ 有了雏形，但存在三个问题：

1. 如果系统中有非常多的交互式任务，它们会一起占据所有的 CPU 时间，导致需要长时间运行的任务一直无法在 CPU 上运行。这种现象称为饥饿（starvation）。
2. 用户程序可能会利用这些规则来控制调度器，从而获得更多计算资源。
3. 如果程序的行为从 CPU 密集转换到 IO 密集，它可能不会得到和其他交互式任务一样的优先级。

为了解决这些问题，需要引入新的规则来提升任务的优先级。

规则 5：经历一个时间周期 $S$ 之后，将系统中所有任务都移动到最高优先级的队列中。

这样可以同时解决第一和第三个问题。但 $S$ 设置为多少是难以量化的。

剩下的第二个问题是规则 4a 和 4b 导致的。解决办法是更好地计量（account）MLFQ 中每一级的 CPU 时间。在给定级别，调度器追踪进程使用了一个时间片的多少；一旦进程用完了它的配额，就将它下降到低一个级别的队列。进程一次还是多次运行用完时间配额是无关紧要的。因此可以重写规则 4a 和 4b。

规则 4：在给定级别，无论任务让出 CPU 多少次，一旦任务用完了时间配额，就降低一级优先级。

MLFQ 的基本规则完成后，还有其他的问题。其中一个较大的问题是如何将 MLFQ 调度器参数化（parameterize）。
