---
title: "Fluent Python Chap23：Attribute 和 Property"
date: 2021-06-06T09:00:28+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: true
---

在 Python 中，数据的属性和处理数据的方法统称属性。方法只是可以调用的属性。

而 property 不改变类接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。

使用点号访问属性时，Python 解释器会调用特殊的方法（如 `__getattr__` 和 `__setattr__`）计算属性。用户自己定义的类可以通过 `__getattr__` 方法实现「虚拟属性」，当访问不存在的属性时即时计算属性的值。

动态创建属性是一种元编程。

大量使用 `[]` 来获取嵌套结构中的属性会使句法冗长，此时可以定义一些类来支持读取属性。类的关键是 `__getattr__` 方法。

仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的 `__getattr__` 方法。尝试获取其他属性时会触发解释器调用 `__getattr__` 方法。这个方法首先查看实例属性字典中有没有指定名称的属性（不是键），这样类的实例便可以处理字典的所有方法。如果没有指定名称的属性，那么 `__getattr__` 方法以那个名称为键，从实例中获取一个元素，传给类的备选构造方法，来深入 JSON 数据的嵌套结构。类的备选构造方法将每一层嵌套转换称一个类实例或实例列表，因此 `__getattr__` 方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。除了在类方法中实现这样的逻辑之外，还可以在特殊的 `__new__` 方法中实现。

尝试读取不存在的属性应该抛出 `AttributeError` 异常，而非 `KeyError` 异常。

如果键名是 Python 的关键字或保留字，在键名或加上一个 `_`。

如果键不是有效的 Python 标识符，可以通过 `str` 类提供的 `s.isidentifier()` 方法根据语言的语法判断 `s` 是否为有效的 Python 标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如 `attr_0`、`attr_1`，等等。

我们通常把 `__init__` 称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法 `__new__`：这是个类方法（使用特殊方式处理，因此不必使用 `@classmethod` 装饰器），必须返回一个实例。返回的实例会作为第一个参数（即 `self`）传给 `__init__` 方法。因为调用 `__init__` 方法时要传入实例，而且禁止返回任何值，所以 `__init__` 方法其实是「初始化方法」。真正的构造方法是 `__new__`。我们几乎不需要自己编写 `__new__` 方法，因为从 `object` 类继承的实现已经足够了。

`__new__` 方法也可以返回其他类的实例，此时，解释器不会调用 `__init__` 方法。

`shelve` 模块是一个简单的数据存储模块，使用 `pickle` 作为数据序列化的格式。

`shelve.open` 高阶函数返回一个 `shelve.Shelf` 实例，这是简单的键值对象数据库，背后由 `dbm` 模块支持：

- `shelve.Shelf` 是 `abc.MutableMapping` 的子类，因此提供了处理映射类型的重要方法。
- 此外，`shelve.Shelf` 类还提供了几个管理 I/O 的方法，如 `sync` 和 `close`；它也是一个上下文管理器。
- 只要把新值赋予键，就会保存键和值。
- 键必须是字符串。
- 值必须是 `pickle` 模块能处理的对象。

对象的 `__dict__` 属性中存储着对象的属性——前提是类中没有声明 `__slots__` 属性，因此，更新实例的 `__dict__` 属性，把值设为一个映射，能快速地在那个实例中创建一堆属性。
