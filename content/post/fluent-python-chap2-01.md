---
title: "Fluent Python Chap2：序列构成的数组"
date: 2021-05-02T09:36:58+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

## 序列类型

Python 标准库用 C 实现了丰富的序列类型：

- 容器序列类型：`list`、`tuple` 和 `collections.deque` 等。这类序列能存放不同类型的元素，包括嵌套的容器。

- 扁平序列类型：`str`、`bytes`、`bytearray`、`memoryview` 和 `array.array` 等。这类序列只能容纳一种类型的元素。

<!--more-->

容器序列存放的是它们所包含的对象的引用，对象可以是任意类型；扁平序列在自己的内存空间存放所包含内容的值，而非不同的对象。换句话说，扁平序列其实是一段连续的内存空间。

由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。

内存中的每个 Python 对象都有一个具有元数据的首部。如 `float` 在 64 位 Python 中结构体表示的 64 位字段：

- `*ob_refcnt`：对象的引用计数；
- `*ob_type`：指向对象类型的指针；
- `*ob_fval`：一个 C 的 `double` 类型保存 `float` 的值。

按照可变性对序列类型分组：

- 可变序列：`list`、`bytearray`、`array.array`、`collections.deque` 和 `memoryview` 等。
- 不可变序列：`tuple`、`str` 和 `bytes` 等。

![collections.abc](https://i.loli.net/2021/05/02/KWdB4MZ9hJPn6vl.png)

超类在左边，继承箭头从子类指向超类。斜体的名称是抽象类和抽象方法。

虽然内建的具体序列类型实际不是 `Sequence` 和 `MutableSequence` 抽象基类的子类，但却是用这些抽象基类注册的虚子类。`issubclass(tuple, abc.Seuqnce)` 和 `issubclass(list, abc.MutableSequence)` 结果都为真。

## 列表推导

列表推导是构建 `list` 的快捷方式，而生成器表达式则可以用来创建其他任何类型的序列。

列表推导和生成器表达式可写出更易读和更快的代码。

通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。

列表推导可以帮助我们把一个序列或是其他可迭代类型中的元素过滤或是加工，然后再新建一个列表。

生成器表达式用于初始化列表以外的序列类型。生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。因此生成器表达式更节省内存。

## 元组

元组除了用作不可变的列表，它还可以用于没有字段名的记录。

元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义。

最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中。

通过元组拆包可以不使用中间变量交换两个变量的值：

```python
b, a = a, b
```

可以用 `*` 运算符把一个可迭代对象拆开作为函数的参数：

```python
t = (20, 8)
quotient, remainder = divmod(*t)  # (2, 4)
```

元组拆包还可以让一个函数可以用元组的形式返回多个值。可以用 `_` 占位符忽略不感兴趣的值。

`*args` 获取不确定数量的参数。在平行赋值中，`*` 前缀只能用在一个变量名前面：

```python
a, b, *rest = range(5)  # (0, 1, [2, 3, 4])
```

但可以出现在赋值表达式的任意位置：

```python
a, *body, c, d = range(5)  # (0, [1, 2], 3, 4)
*head, b, c ,d = range(5)  # ([0, 1], 2, 3, 4)
```

元组拆包可以用于嵌套结构中，只要这个接受元组的嵌套结构符合表达式本身的嵌套结构。

`collections.namedtuple` 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。这个带名字的类对调试程序有很大帮助。

用 `namedtuple` 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为 Python 不会用 `__dict__` 来存放这些实例的属性。

除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性：

- `_fields` 类属性：一个包含这个类所有字段名称的元组。
- 类方法 `_make(iterable)`：用 `_make()` 通过接受一个可迭代对象来生成这个类的一个实例。
- 实例方法 `_asdict()`：`_asdict()` 把具名元组以 `collections.OrderedDict` 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。

除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。另外，元组没有 `__reversed_` 方法。

## 切片

切片和区间省略最后一个元素的好处：

- 当只有最后一个位置信息时，我们也可以快速看出切片和区间里有几个元素：`range(3)` 和 `my_list[:3]` 都返回 3 个元素。
- 当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标 `(stop - start)` 即可。
- 这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成 `my_list[:x]` 和 `my_list[x:]` 就可以了。

可以用 `s[a:b:c]` 的形式对 `s` 在 `a` 和 `b` 之间以 `c` 为间隔取
值。`c` 的值还可以为负，负值意味着反向取值。

```python
s = 'bicycle'
s[::3]   # 'bye'
s[::-1]  # 'elcycib'
s[::-2]  # 'eccb'
```

对 `seq[start:stop:step]` 进行求值的时候，Python 会调用 `seq.__getitem__(slice(start, stop, step))`。

可以给切片命名，就像电子表格软件里给单元格区域取名字一样。

`[]` 运算符里还可以使用以逗号分开的多个索引或者是切片。`__getitem__` 和 `__setitem__` 特殊方法处理 `[]` 运算符，接收 `a[i, j]` 中的索引作为元组。换句话说，要对 `a[i, j]` 求值，Python 调用了 `a.__getitem__((i, j))`。

NumPy 库中二维的 `numpy.ndarray` 就用 `a[i, j]` 这种形式来获取，二维切片用 `a[m:n, k:l]` 的方式来获取。

Python 内置的序列类型除了 `memoryview` 都是一维的，因此它们只支持单一的索引或切片，成对出现的索引是没有用的。

省略（ellipsis）符的正确书写方法是三个英语句号（...），而不是 Unicdoe 码位 U+2026 表示的半个省略号（…）。省略在 Python 解析器眼里是一个符号，而实际上它是 `Ellipsis` 对象的别名，而 `Ellipsis` 对象又是 `ellipsis` 类的单一实例。

省略符可以作为参数传递给函数，如 `f(a, ... z)`；可以作为切片规范的一部分，如 `a[i:...]`。

NumPy 使用省略符作为多维数组切片的快捷方式，如 `x[i, ...]` 是四维数组 `x[i, :, :, :]` 的缩写。

如果把切片放在赋值语句的左边，或把它作为 `del` 操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。

```python
l = list(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20, 30]    # [0, 1, 20, 30, 5, 6, 7, 8, 9]
del l[5:7]           # [0, 1, 20, 30, 5, 8, 9]
l[3::2] = [11, 22]   # [0, 1, 20, 11, 5, 22, 9]
l[2:5] = 100         # TypeError: can only assign an iterable
l[2:5] = [100]       # [0, 1, 100, 22, 9]
```

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

## `+` 和 `*` 操作符

一般默认序列支持 `+` 和 `*` 操作。通常 `+` 号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python 会新建一个包含同样类型数据的序列来作为拼接的结果。

最好用列表推导来初始化嵌套列表。

## 序列的增量赋值

增量赋值运算符 `+=` 和 `*=` 的表现取决于它们的第一个操作对象。

`+=` 背后的特殊方法是 `__iadd__`，用于「就地加法」。但是如果一个类没有实现这个方法的话，Python 会退一步调用 `__add__`。

同理 `*=` 对应于 `__imul_`。

对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。`str` 是一个例外，因为对字符串做 `+=` 实在是太普遍了，所以 CPython 对它做了优化。为 `str` 初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作。

不要把可变对象放在元组里面。

增量赋值不是一个原子操作。

查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

## `list.sort` 方法和内建函数 `sorted`

`list.sort` 方法会就地排序列表，返回值是 `None`。

在这种情况下返回 `None` 其实是 Python 的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 `None`，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。

内建函数 `sorted` 会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。

二者都有两个可选的关键字参数：

- `reverse`：如果为 `True`，将序列降序输出；默认为 `False`。
- `key`：一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。

## 用 `bisect` 来管理已排序的序列

`bisect` 模块包含两个主要函数，`bisect` 和 `insort`，两个函数都利用二分查找算法来在有序序列中查找或插入元素。

`bisect(haystack, needle)` 在 `haystack`（干草垛）里搜索 `needle`（针）的位置，该位置满足的条件是，把 `needle` 插入这个位置之后，`haystack` 还能保持升序。

`bisect` 可以通过两个可选参数 `lo` 和 `hi` 来缩写搜寻的范围。`lo` 的默认值是 `0`，`hi` 的默认值是序列的长度。

`bisect` 函数其实是 `bisect_right` 函数的别名。

`insort(seq, item)` 把变量 `item` 插入到序列 `seq` 中，并能保持 `seq` 的升序顺序。

## 当列表不是首选时

如果我们需要一个只包含数字的列表，那么 `array.array` 比 `list` 更高效。数组支持所有跟可变序列有关的操作，包括 `.pop`、`.insert` 和 `.extend`。另外，数组还提供从文件读取和存入文件的更快的方法，如 `.frombytes` 和 `.tofile`。

创建数组需要一个类型码，这个类型码用来表示在底层的 C 语言应该存放怎样的数据类型。

`memoryview` 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。

`memoryview.cast` 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。

`collections.deque` 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的数据类型。