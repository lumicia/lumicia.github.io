---
title: "Fluent Python Chap19：协程"
date: 2021-06-05T13:54:49+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

从句法上看，协程与生成器类似，都是定义体中包含 `yield` 关键字的函数。可是，在协程中，`yield` 通常出现在表达式的右边（例如，`datum = yield`），可以产出值，也可以不产出——如果 `yield` 关键字后面没有表达式，那么生成器产出 `None`。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 `.send(datum)` 方法，而不是 `next(...)` 函数。通常，调用方会把值推送给协程。

`yield` 关键字甚至还可以不接收或传出数据。不管数据如何流动，`yield` 都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。

从根本上把 `yield` 视作控制流程的方式，这样就好理解协程了。

<!--more-->

生成器的调用方可以使用 `.send(...)` 方法发送数据，发送的数据会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。

`yield` 在表达式中使用；如果协程只需从客户那里接收数据，那么产出的值是 `None`——这个值是隐式指定的，因为 `yield` 关键字右边没有表达式。

首先要调用 `next(...)` 函数，因为生成器还没启动，没在 `yield` 语句处暂停，所以一开始无法发送数据。

协程可以身处四个状态中的一个。当前状态可以使用 `inspect.getgeneratorstate(...)` 函数确定，该函数会返回下述字符串中的一个：

- `GEN_CREATED`：等待开始执行；
- `GEN_RUNNING`：解释器正在执行；
- `GEN_SUSPENDED`：在 yield 表达式处暂停；
- `GEN_CLOSED`：执行结束。

因为 `send` 方法的参数会成为暂停的 `yield` 表达式的值，所以，仅当协程处于暂停状态时才能调用 `send` 方法。

最先调用 `next(...)` 函数这一步通常称为「预激」（prime）协程（即，让协程向前执行到第一个 `yield` 表达式，准备好作为活跃的协程使用）。

关键的一点是，协程在 `yield` 关键字所在的位置暂停执行。

使用协程的好处是，需要在函数中跟踪的变量声明为局部变量即可，无需使用实例属性或闭包在多次调用之间保持上下文。

为了简化协程的用法，有时会使用一个预激装饰器。

使用 `yield from` 句法调用协程时，会自动预激。

---

协程中未处理的异常会向上冒泡，传给 `next` 函数或 `send` 方法的调用方（即触发协程的对象）。

终止协程的一种方式：发送某个哨符值，让协程退出。内置的 `None` 和 `Ellipsis` 等常量经常用作哨符值。`Ellipsis` 的优点是，数据流中不太常有这个值。

可以在生成器对象上调用 `throw` 和 `close` 方法，显式地把异常发给协程。

---

某些协程不会产出值，而是在最后返回一个值（通常是某种累计值）。

在生成器 `gen` 中使用 `yield from subgen()` 时，`subgen` 会获得控制权，把产出的值传给 `gen` 的调用方，即调用方可以直接控制 `subgen`。与此同时，`gen` 会阻塞，等待 `subgen` 终止。

`yield from` 可用于简化 `for` 循环中的 `yield` 表达式。

`yield from x` 表达式对 `x` 对象所做的第一件事是，调用 `iter(x)`，从中获取迭代器。因此，`x` 可以是任何可迭代对象。

`yield from` 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。

委派生成器是包含 `yield from <iterable>` 表达式的生成器函数。子生成器是从 `yield from` 表达式中 `<iterable>` 部分获取的生成器。调用方指代调用委派生成器的客户端代码。

委派生成器在 `yield from` 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出 `StopIteration` 异常，并把返回值附加到异常对象上，此时委派生成器会恢复。

因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派生成器使用 `yield from` 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 `yield from` 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 `yield` 表达式的简单生成器结束；不过，也能以任何可迭代的对象结束。

任何 `yield from` 链条都必须由客户驱动，在最外层委派生成器上调用 `next(...)` 函数或 `.send(...)` 方法。可以隐式调用，例如使用 `for` 循环。

`yield from` 的行为：

- 子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。
-  使用 `send()` 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 `None`，那么会调用子生成器的 `__next__()` 方法。如果发送的值不是 `None`，那么会调用子生成器的 `send()` 方法。如果调用的方法抛出 `StopIteration` 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。
-  生成器退出时，生成器（或子生成器）中的 `return expr` 表达式会触发 `StopIteration(expr)` 异常抛出。
- `yield from` 表达式的值是子生成器终止时传给 `StopIteration` 异常的第一个参数。

yield from 结构的另外两个特性与异常和终止有关：

-  传入委派生成器的异常，除了 `GeneratorExit` 之外都传给子生成器的 `throw()` 方法。如果调用 `throw()` 方法时抛出 `StopIteration` 异常，委派生成器恢复运行。`StopIteration` 之外的异常会向上冒泡，传给委派生成器。
-  如果把 `GeneratorExit` 异常传入委派生成器，或者在委派生成器上调用 `close()` 方法，那么在子生成器上调用 `close()` 方法，如果它有的话。如果调用 `close()` 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 `GeneratorExit` 异常。

