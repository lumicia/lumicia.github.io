---
title: "程序员的自我修养 Chap2：编译和链接"
date: 2021-05-16T08:21:27+08:00
categories: ["Compiler Principle"]
tags: ["程序员的自我修养：装载、链接与库"]
draft: false
---

通常在集成开发环境（IDE）中将编译和链接的过程合并到一起，称为构建（Build）。IDE 隐藏了许多细节，使得开发者更容易使用，但程序运行过程中遇到性能瓶颈或其他问题时，却又难以看到问题背后的本质。

<!--more-->

## 编译的整个过程

将上一章的 Hello World 程序保存为 `hello.c` 文件，然后使用 GCC 来编译，`$` 符号指示在命令行输入的命令：

```bash
$ gcc hello.c
$ ./a.out
Hello World
```

该编译过程可以分解为 4 个步骤：

- 预处理（Prepressing）；
- 编译（Compilation）；
- 汇编（Assembly）；
- 链接（Linking）。

<img src="https://i.loli.net/2021/05/16/uATK1gP5M6bodrv.png" alt="gcc 编译过程" style="zoom:50%;" />

### 预编译

源代码文件 `hello.c` 和相关的头文件，如 `stdio.h` 等被与编译器 cpp 预编译为 `.i` 文件。对于 C++ 程序来说，它的源代码文件的扩展名可能是 `.cpp` 或 `.cxx`，头文件的扩展名可能是 `.hpp`，而预编译后的文件扩展名是 `.ii`。

预编译的命令，`-E` 表示只进行预编译：

```bash
$ gcc -E hello.c -o hello.i
```

或

```bash
$ cpp hello.c > hello.i
```

预编译过程主要处理那些源代码文件中的以 `#` 开头的预编译指令，如 `#include`、`#define` 等。主要处理规则：

- 将所有的 `#define` 删除，并展开所有的宏定义；
- 处理所有条件预编译指令，如 `#if`、`#ifdef`、`#elif`、`#else`、`#endif`；
- 处理 `#include`，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，因为被包含的文件可能还包含其他文件。
- 删除所有以 `//`  和 `/* */` 标记的注释；
- 添加行号和文件名标识，如 `#2 "hello.c" `，以便于编译时编译器产生调试用的行号信息与用于编译时产生编译错误或警告时能够显示行号；
- 保留所有 `#pragma` 指令，因为编译器必须要使用它们；

经过预编译后的 `.i` 文件不包含任何宏定义，因为所有的宏都已经展开，并且包含的文件也已经插入到 `.i` 文件中。当无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。

### 编译

编译将预处理后的文件进行词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。编译过程是整个程序构建的核心部分。

编译命令：

```bash
$ gcc -S hello.i -o hello.s
```

`cc1` 程序可以将预编译和编译两个步骤合并成一个步骤。或使用如下命令

```bash
$ gcc -S hello.c -o hello.s
```

都可以得到汇编输出文件 `hello.s`。

`gcc` 命令是其他后台的预编译和编译程序的包装，根据不同的参数调用预编译编译程序 `cc1`、汇编器 `as`、链接器 `ld`。

### 汇编

汇编器将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎到对应一条机器指令。汇编过程可以通过调用汇编器 `as` 来完成，得到目标文件（Object File）：

```bash
$ as hello.s -o hello.o
```

或

```bash
$ gcc -c hello.s -o hello.o
```

或

```bash
$ gcc -c hello.c -o hello.o
```

### 链接

链接器将目标文件和其他库文件链接起来，得到最终的可执行文件。

## 编译器

编译器是将高级语言翻译成机器语言的工具。

使用机器指令或汇编语言编写程序非常费力、乏味，且开发效率底下。另外编写出来的程序依赖于特定机器，不同 CPU 下编写的程序不能在其他 CPU 下运行，需要重新编写。于是出现了高级语言。

高级语言可以让程序员更加关注程序逻辑本身，尽量少地考虑计算机本身的限制。高级语言的开发效率更高，且可移植。

编译过程可以分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

<img src="https://i.loli.net/2021/05/16/qeCI8UY9dg7xE5m.png" alt="编译过程" style="zoom:50%;" />

以下面的 C 代码为例来详细讲述编译过程：

```c
array[index] = (index + 4) * (2 + 6)
```

### 词法分析

首先将源代码输入到扫描器（Scanner）。扫描器简单地进行词法分析，用类似于有限状态机（Finite State Machine）的算法将源代码的字符序列分割成一系列的记号（Token）。

上面的 C 代码总共包含了 28 个非空字符，经过扫描以后产生 16 个记号。

| 记号  | 类型     |
| :---- | -------- |
| array | 标识符   |
| [     | 左方括号 |
| index | 标识符   |
| ]     | 右方括号 |
| =     | 赋值     |
| (     | 左圆括号 |
| index | 标识符   |
| +     | 加号     |
| 4     | 数字     |
| )     | 右圆括号 |
| *     | 乘号     |
| (     | 左圆括号 |
| 2     | 数字     |
| +     | 加号     |
| 6     | 数字     |
| )     | 右圆括号 |

词法分析产生的记号一般分为：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。

在识别记号的同时，扫描器还会将标识符存放到符号表，将数字、字符串常量存放到文字表等，以供后面的步骤使用。

lex 程序可以实现词法扫描，按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。因为有 lex，编译器的开发者无需为每个编译器开发一个独立的词法扫描器，只需根据需要改变词法规则。

对于有预处理的语言，如 C 语言，它的宏替换和文件包含等工作一般不归入编译器的范围内而交给一个独立的预处理器。

### 语法分析

语法分析器（Grammar Parser）对扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree）。分析过程采用上下文无关语法（Context-free Grammar）。简单来说，由语法分析器生成的语法树就是以表达式（Expression）为节点的树。

![语法树](https://i.loli.net/2021/05/16/5Q9lRSHam1rNWcT.png)

整个语句可以看作一个赋值表达式：赋值表达式左边是一个数组表达式，右边是一个乘法表达式；数组表达式又由两个符号表达式组成，等等。

符号和数字是最小的表达式，它们不能由其他表达式组成，因此作为整个语法树的叶节点。

语法分析时确定运算符的优先级和含义。如乘法表达式的优先级比加法高， 圆括号的优先级比乘法高，等等。另外有些符号有多重含义，如星号可以表示乘法表达式，也可以表示对指针取内容的表达式，所以语法分析节点必须对这些内容进行区分。如果出现表达式不合法，如括号不匹配、表达式中缺少操作等，编译器会报告语法分析阶段的错误。

语法分析可以用 yacc（Yet Another Compiler Compiler）工具来实现。yacc 根据用户给定的语法规则对输入的记号序列进行解析，从而构建初始出一颗语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，无需为每个编译器编写一个语法分析器，所以它被称为「编译器编译器」。

### 语义分析

语义分析通过语义分析器（Semantic Analyzer）来完成。语法分析只能判断语句的语法是否合法，不能判断语句是否有意义。比如两个指针做乘法运算在语法上是合法的，但在语义上是没有意义的。

编译器能分析的语义是静态语义（Static Semantic），指在编译期能确定的语义。在运行时才能确定的语义称为动态语义（Dynamic Semantic）。

静态语义通常包括声明和类型的匹配，类型的转换。如将一个浮点型表达式赋值给一个整型的表达式，其中隐含了一个浮点型到整型的转换过程，语义分析需要完成这个步骤。如将一个浮点型赋值给一个指针，语义分析程序会发现类型不匹配，编译器将会报错。

动态语义一般指在运行时出现的语义相关的问题，如将 0 作为除数。

经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果一些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。语义分析后的语法树：

![标识语义后的语法树](https://i.loli.net/2021/05/16/RgCoDOYA6alsmcQ.png)

每个表达式（包括符号和数字）都被标识了类型。例子中的表达式都是整型的，所以无需做转换。语义分析器还对符号表中的符号类型也做了更新。

### 中间语言生成

现代的编译器在源代码级别往往有一个优化过程。源代码优化器（Source Code Optimizer）会在源代码级别进行优化。

`(2 + 6)` 这个表达式就可以被优化掉，因为它的值在编译期就可以确定。

优化后的语法树：

![优化后的语法树](https://i.loli.net/2021/05/16/U6upge9v5aAEObI.png)

直接在语法树上做优化比较困难，因此源代码优化器往往将个语法树转换成中间代码（Intermediate Code）。它是语法树的顺序标识，非常接近目标代码，但一般跟目标机器和运行时环境无关，如不包含数据大小、变量地址和寄存器名字等。

常见的中间代码类型有三地址码（Three-address Code）和 P-代码（P-Code）。

最基本的三地址码：

```
x = y op z
```

表示将变量 `y` 和 `z` 进行 `op` 操作后，赋值给 `x`。这里的 `op` 操作可以是算术运算，也可以是其他任何可以应用到 `y` 和 `z` 的操作。一个三地址码语句包含三个变量的地址，因此得名。

将上面的语法树翻译成三地址码如下：

```
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```

为了使所以操作符合三地址的形式，需要用到几个临时变量。在三地址的基础上进行优化时，优化程序会将 `2 + 6` 的结果计算出来，得到 `t1 = 6`。然后将后面代码中的的 `t1` 替换成数字 `6`。`t3` 可以省略，因为 `t2` 可以重复利用。优化过后的代码：

```
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```

中间代码使得编译器可以分为前端和后端两部分。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的多个后端。

### 目标代码生成和优化

编译器后端主要包括代码生成期（Code Generator）和目标代码优化器（Target Code Optimizer）。

代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有不同的字长、寄存器、整数数据类型和浮点数数据类型等。代码生成器可能会利用上面的中间代码生成下面的代码（用 x86 的汇编语言来表示，并假设 `index` 的类型是 `int`，`array` 的类型是 `int` 数组）：

```assembly
movl index, %ecx           ; value of index to ecx
addl $4, %ecx              ; ecx = ecx + 4
mull $8, %ecx              ; ecx = ecx * 8
movl index, %eax           ; value of index to eax
movl %ecx, array(,eax, 4)  ; array[index] = ecx
```

最后目标代码优化器对上述目标代码进行优化，如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上例中乘法由一条相对复杂的基址比例变址寻址（Base Index Scale Addressing）的 `lea` 指令完成，随后由一条 `mov` 指令完成最后的赋值操作，这条 `mov` 指令的寻址方式与 `lea` 是一样的。

```assembly
movl index, %edx
leal 32(, %edx, 8), %eax
movl %eax, array(, %edx, 4)
```

编译器复杂的原因：

- 高级编程语言本身就非常复杂。
- 现代的 CPU 具有非常复杂的特性，为了支持这些特性，编译器的机器指令优化过程也变得十分复杂。
- 编译器支持多中硬件平台，即允许编译器编译出多种目标 CPU 的代码，这导致编译器的指令生成过程更为复杂。

最后的问题是生成的目标代码中 `index` 和 `array` 的地址还没有确定。如果都和上面的源代码定义在同一个编译单元中，那么编译器可以为 `index` 和 `array` 分配空间，确定它们的地址；如果定义在其他程序模块呢？

事实上，其他模块定义的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。

## 链接器的历史

在只有机器语言的年代，要运行程序，程序员手动将程序写入到存储设备——纸上（即在纸带上打孔）。

假设有一种计算机，它的每条指令是 1 字节，即 8 位。假设有一种跳转指令，它的高 4 位是 `0001`，表示这是一条跳转指令；低 4 位存放跳转目的地的绝对地址。

```
0  0001 0100
1  ...
2  ...
3  ...
4  1000 0111
5  ...
```

上面程序的第一条指令是一条跳转指令，目的地地址是第 5 条指令（第 5 条指令的绝对地址是 4）。为了将 0 和 1 映射到纸带上，可以规定纸带上每行有 8 个孔位，每个孔代表 1 位，穿孔表示 0，未穿孔表示 1。

程序写好之后可能还会经常修改。如在第 1 条指令之后、第 5 条指令之前插入一条或多条指令，那么第 5 条指令及后面的指令的位置会相应地往后移动，原先第 1 条指令的低 4 位的数字需要相应地调整。这个过程需要程序员手动重新计算每个子程序或跳转的目标地址。这种重新计算各个目标的地址的过程称为重定位（Relocation）。重定位十分繁琐耗时，且容易出错。

如果有多条纸带的程序，程序之间可能会有类似的跨纸带跳转，这种程序经常修改导致跳转目标地址变化在程序拥有多个模块时更加严重。手动绑定进行指令修正以确保所有的跳转目标地址都正确的方式，在程序规模越来越大以后变得越来越复杂和繁琐。

于是发明了汇编语言，使用接近人类自然语言的各种符号和标记来帮助记忆指令。汇编还可以使用符号来标记位置。最重要的是汇编可以将人们从具体的指令地址中逐步解放出来。汇编器在每次汇编程序的时候重新计算符号地址，然后将所有引用该符号地址的指令修正到这个正确的地址。符号（Symbol）用来表示一个地址，这个地址可能是一段子程序（后发展为函数）的起始地址，也可以表示一个变量的起始地址。

汇编使得程序员摆脱了手动跳转地址的繁琐工作，提高了生产力。随之而来的是软件规模也开始日渐庞大，程序的代码量开始快速膨胀。为了使代码更容易阅读和理解，开始将代码按照功能或性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其他结构来组织。

如 C 语言中最小单位是变量和函数，若干个变量和函数组成一个模块，存放在一个扩展名为 `.c` 的源代码文件中，然后将这些源代码文件按照目录结构来组织。Java 中每个类是一个基本的模块，若干个模块组成一个包（Package），若干个包组合成一个程序。

按照层次与模块来存储和组织源代码有很多好处，如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。

程序分割成多个模块之后，模块之间如何组合形成一个单一的程序是必须解决的问题。模块之间组合的问题可以归结为模块之间如何通信的问题。如 C/C++ 模块之间的通信方式有两种，一种是模块间的函数调用，另一种是模块间的变量访问。函数访问必须知道目标函数的地址，变量访问也必须知道目标变量的地址，所以这两种方式也可以归结为一种方式，那就是模块间符号的引用。

## 静态链接

每个源代码模块独立编译，然后将它们组合起来。这个组装模块的过程称为链接（Linking）。链接主要工作是把每个模块之间相互引用的部分处理好，使得各个模块之间能正确地衔接。从原理上讲，链接就是把一些指令对其他符号地址的引用加以修正。

链接过程主要包括：地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等。

符号决议也称为符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution）、地址绑定（Address Binding）、指令绑定（Instruction Binding）等。但「决议」更偏向静态链接，「绑定」更偏向动态链接，即它们所使用的范围不一样。书中静态链接统一称为符号决议。

基本的静态链接过程：

<img src="https://i.loli.net/2021/05/16/Xps8KJB71mgDLZt.png" alt="静态链接" style="zoom:50%;" />

每个模块的源代码文件（如 `.c`）经过编译器编译为目标文件（一般扩展名为 `.o` 或 `.obj`），目标文件和库一起链接形成最终的可执行文件。最常见的库是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。

库其实是一组目标文件的包，把最常用的代码编译成目标文件后打包存放。

如果在模块 A 中使用另一个模块 B 中的函数 `foo`，A 中每一处调用 `foo` 的地方都必须确切知道 `foo` 的地址，但由于每个模块都是单独编译的，编译器编译模块 A 的时候它不知道 `foo` 的地址，所以它暂时把这些调用 `foo` 的指令的目标地址搁置，等待最后链接的时候由链接器修正这些指令的目标地址。

如果在目标文件 A 中有一个全局变量 `var`，要在目标文件 B 中访问 `var` 并为其赋值。

```assembly
movl $0x2a, var
```

给 `var` 赋值 `0x2a` 相当于 C 语言中的语句 `var = 42`。编译目标文件 B，得到指令的机器码。三组数字分别代表 `mov` 指令码、目标地址、源常量。

```
C705  00000000  2a000000
```

由于在编译目标文件 B 的时候，编译器不知道 `var` 的目标地址，所以编译器在每个确定地址的情况下，将这条 `mov` 指令的目标地址置为 0，等待链接器将目标文件 A 和 B 链接起来的时候再修正。假设 A 和 B 链接后，`var` 的地址是 `0x1000`，那么链接器就会将这个指令的目标地址部分修改为 `0x1000`。这个地址修正的过程也称为重定位（Relocation）。每个修正的地方称为重定位入口（Relocation Entry）。