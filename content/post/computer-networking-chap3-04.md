---
title: "计算机网络 Chap3 04：可靠数据传输"
date: 2021-05-06T16:00:18+08:00
categories: ["Computer Networking"]
tags: ["计算机网络：自顶向下方法"]
draft: false
---

可靠数据传输提供给上层实体的服务抽象：一个能够传输数据的可靠信道。在可靠信道内，没有传输的数据比特损坏（从 0 变成 1，或反之）或丢失，并且以发送时的顺序交付。

可靠数据传输协议负责实现该服务抽象。

<!--more-->

上一层调用 `rdt_send()` 后就会调用数据传输协议的发送端。然后传递数据给接收端的上一层。

当分组到达信道的接收端时，接收端会调用 `rdt_rcv()`。当 `rdt` 协议想将数据交付给上一层时，会调用 `deliver_date()`。

在本节中用术语「分组」一词替代传输层的「报文段」，因为本节中的理论会应用到一般的计算机网络中，而不仅仅是互联网传输层，通用术语「分组」在此处也许会更加合适。

本节仅考虑单向数据传输（unidirectional data transfer）的情况，即数据传输从发送端到接收端。可靠的双向数据传输（bidirectional data transfer）概念上不会更难但解释起来更单调乏味。注意 `rdt` 协议仍需要在发送端和接收端两个方向上传输分组。除了交换含有待传送的数据分组外，`rdt` 的发送端和接收端还需往返交换控制分组。`rdt` 的发送端和接收端都要通过调用 `udt_send()` 发送分组给对方。

## 构建一个可靠舒传输协议

### rdt1.0

从最简单的情况开始，底层信道是完全可靠的，称为 `rdt1.0`。

`rdt1.0` 有限状态机的发送端和接收端定义如下图：

<img src="https://i.bmp.ovh/imgs/2021/05/27ba4ce1925ad29e.png" alt="rdt1.0" style="zoom: 33%;" />

注意发送端和接收端的有限状态机是单独定义的。

箭头指示有限状态机中协议从一个状态到另一个状态的转换。

横线上面是引起状态转换的原因，下面是转换时发生的动作。转换事件没有发生动作，或没有事件时发生动作，分别在横线下面和上面用 $\Lambda$ 符号表示。

短横线表示有限状态机的初始状态。

### rdt2.0

一种底层信道更真实的模型是分组中的比特会损坏。但仍假设所有传输的分组都会以传送的顺序被接收。

为了知道所发送的分组是否正确无误地到达接收端，接收端需要向发送端返回一个控制信息，让发送端知道哪些分组正确接收，哪些出错而需要重传。基于重传的可靠数据传输协议称为 ARQ（Automatic Repeat reQuest）协议。

ARQ 协议需要具有三个额外的能力来处理比特差错的情况：

- 错误检测；
- 接收端反馈；
- 重传。

<img src="https://i.bmp.ovh/imgs/2021/05/465834d346f15a08.png" alt="rdt2.0 发送端" style="zoom:33%;" />

<img src="https://i.bmp.ovh/imgs/2021/05/fb47e21a65fa39ba.png" alt="rdt2.0 接收端" style="zoom:33%;" />

ACK 表示肯定确认，NAK 表示否定确认。

当发送端处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据。因此 `rdt2.0` 协议称为停等（stop-and-wait）协议。

`rdt2.0` 协议的问题在于 ACK 或 NAK 分组也可能受损。解决方法是在数据分组中添加分组序号，接收端只需要检查序号即可确定接收的分组是否为一次重传。于是得到 `rdt2.1` 协议。

<img src="https://i.bmp.ovh/imgs/2021/05/89f5533094cc1280.png" alt="rdt2.1 发送端" style="zoom:50%;" />

<img src="https://i.bmp.ovh/imgs/2021/05/9e6dae1b5d4d219b.png" alt="rdt2.1 接收端" style="zoom:50%;" />

对于停等协议只需要 1 比特的序号，协议状态必须反映出目前正发送的分组或希望接收的分组的序号是 0 还是 1。`rdt2.1` 与 `rdt2.0` 唯一的不同是序号处理方法的不同。

如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，让发送端接收到对同一个分组的两个 ACK，则发送端知道接收端没有正确接收到在被确认两次的分组后面的分组。于是可以实现一个无 NAK 的可靠数据传输协议 `rdt2.2`。

<img src="https://i.bmp.ovh/imgs/2021/05/94bf5ae8aef53656.png" alt="rdt2.2 发送端" style="zoom:50%;" />

<img src="https://i.bmp.ovh/imgs/2021/05/237138f1c8e7f3b3.png" alt="rdt2.2 接收端" style="zoom:50%;" />

`rdt2.2` 和 `rdt2.1` 的区别在于接收端此时必须包括由一个 ACK 报文所确认的分组序号，发送端此时必须检查接收到的 ACK 报文中被确认的分组序号。

### rdt3.0

假定除了比特损坏外，底层信道还会丢包。现在需要关注另外两个问题：

- 怎样检测丢包；
- 如何处理丢包。

可以使用在 `rdt2.2` 中的技术如检验和、序号、ACK 分组和重传来处理丢包。

这里让发送端负责检测和恢复丢包工作。发送端通过一个时延来确定分组已丢失。为了实现基于时间的重传机制，需要一个倒计时定时器（countdown timer），在一个给定的时间量过期后，可中断发送端。发送端需要做到：

1. 每次发送一个分组时，便启动一个定时器；
2. 响应定时器中断；
3. 终止定时器。

<img src="https://i.bmp.ovh/imgs/2021/05/378a67d2725a0db2.png" alt="rdt3.0 发送端" style="zoom:50%;" />

超时引入了冗余分组，而 `rdt2.2` 中的接收端已经能够处理冗余分组，因此 `rdt3.0` 的接收端和 `rdt2.2` 中的一致。

## 流水线可靠数据传输协议

`rdt3.0` 协议功能正确，但由于是停等协议，性能存在问题。

流水线（pipeline）技术不使用停等方式运行，允许发送端发送多个分组而无需等待确认。

流水线技术的影响：

- 必须增加序号范围；
- 协议的发送端和接收端可能必须缓存多个分组；
- 所需序号范围的对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。

解决流水线差错恢复的两种基本方法：

- GBN（Go-Back-N）
- SR（Selective Repeat）

## GBN

GBN 协议允许发送端发送多个分组而无需等待确认，但在流水线中未确认的分组数不能超过某个最大允许数 N。

基序号（base）定义为最早的未确认分组的序号，下一个序号（nextseqnum）定义为最小的未使用序号（即下一个待发送分组的序号）。

序号可以分割成 4 段：

- `[0, base - 1]` 段内的序号对应于已经发送并确认的分组；
- `[base, nextseqnum - 1]` 段内对应已经发送但未确认的分组；
- `[nextseqnum, base + N - 1]` 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话；
- 大于等于 `base + N` 的序号是不能使用的，直到当前流水线中未确认的分组已经得到确认为止。

从发送端看 GBN 协议中的序号范围：

<img src="https://i.loli.net/2021/05/13/rf5ywl8apECVMKt.png" alt="从发送端看 GBN 协议中的序号范围" style="zoom: 33%;" />

那些已发送但未确认的分组的许可序号范围可以看成一个在序号范围内的长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动，因此 N 常被称为窗口长度（window size），GBN 协议常被称为滑动窗口协议（sliding-window protocol）。

为 FSM 添加变量 `base` 和 `nextseqnum` 及变量操作和变量相关的条件动作得到扩展 FSM。扩展 FSM 描述的发送端和接收端：

<img src="https://i.loli.net/2021/05/13/2SgWXyBkTqNCze3.png" alt="扩展 FSM 描述的发送端" style="zoom:50%;" />

<img src="https://i.loli.net/2021/05/13/Z5EqHbrzQap4xMT.png" alt="扩展 FSM 描述的接收端" style="zoom:50%;" />

GBN 发送方必须响应三种类型的事件：

- 上层的调用；
- 收到一个 ACK；
- 超时事件。

在 GBN 协议中，对序号为 n 的分组的确认采取累积确认（cumulative acknowledgement）的方式，表明接收端已正确接收到序号为 n 的以前且包括 n 在内的所有分组。

## 选择重传

GBN 在窗口长度和带宽时延积很大时会出现性能问题。

SR 协议可以避免不必要的重传，让发送端仅重传那些它怀疑在接收端出错的分组。这种个别的、按需的重传要求接收端逐个确认正确接收的分组。