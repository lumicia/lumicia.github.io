---
title: "Fluent Python Chap2：序列构成的数组"
date: 2021-05-02T09:36:58+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

## 序列类型

Python 标准库用 C 实现了丰富的序列类型：

- 容器序列类型：`list`、`tuple` 和 `collections.deque` 等。这类序列能存放不同类型的元素，包括嵌套的容器。
- 扁平序列类型：`str`、`bytes`、`bytearray`、`memoryview` 和 `array.array` 等。这类序列只能容纳一种类型的元素。

<!--more-->

容器序列存放的是它们所包含的对象的引用，对象可以是任意类型；扁平序列则在自己的内存空间存放所包含内容的值，而非不同的对象。换句话说，扁平序列其实是一段连续的内存空间。

由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型的机器值。

内存中的每个 Python 对象都有一个存放元数据的首部。如在 64 位 Python 中表示 `float` 的结构体所具有的 64 位字段：

- `*ob_refcnt`：对象的引用计数；
- `*ob_type`：指向对象类型的指针；
- `*ob_fval`：一个 C 的 `double` 类型，用于保存 `float` 的值。

也可以按照可变性对序列类型分组：

- 可变序列：`list`、`bytearray`、`array.array`、`collections.deque` 和 `memoryview` 等。
- 不可变序列：`tuple`、`str` 和 `bytes` 等。

![collections.abc](https://i.loli.net/2021/06/10/FvTZdK48ukjfmXH.png)

超类在左边，继承箭头从子类指向超类。斜体的名称是抽象类和抽象方法。

可变序列从不可变序列继承了所有的方法，并实现了其他的一些方法。虽然内置的具体序列类型实际不是 `Sequence` 和 `MutableSequence` 抽象基类的子类，但却是用这些抽象基类注册的虚子类。`issubclass(tuple, abc.Seuqnce)` 和 `issubclass(list, abc.MutableSequence)` 的测试结果都为真。

## 列表推导

`list` 是一个可变容器类型，列表推导是构建 `list` 类型序列的快捷方式，而生成器表达式则可以用来生成任意类型的元素来填充序列。

列表推导开头是元素的值或元素求值的表达式。列表推导等价于在 `for` 循环中用 `append` 方法追加元素。如果列表推导后面有 `if` 语句，则相当于在每次 `for` 循环中做判断。

列表推导和生成器表达式可写出更易读和更快的代码。

通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。

在 Python 中，`[]`、`{}` 和 `()` 中的换行会被忽略，因此构建多行的列表、列表推导、生成器表达式、字典或其他类似的数据结构时，无需使用 `\` 续行符。这些分隔符用于以 `,` 分隔的项的序列时，会忽略结尾的 `,`。

在 Python 3 中，列表推导、生成器表达式、以及相似的集合推导、字典推导都具有自己的局部作用域，就和函数一样。在表达式中赋值的变量是局部的，但周围作用域中的变量仍能被引用。局部变量不会遮蔽周围作用域中的变量。

列表推导可以通过过滤或转化一个序列或是其他可迭代类型中的元素，来新建一个列表。`filter` 和 `map` 内置函数的组合也能做到这一点，但可读性较差。

列表推导中如果有两个 `for` 语句，与普通的嵌套的两个 `for` 语句顺序一致。

生成器表达式用于生成列表以外的序列类型。生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。因此生成器表达式更节省内存。

如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围
起来。如果参数多于一个，则括号是必需的。

```python
symbols = '$¢£¥€¤'

tuple(ord(symbol) for symbol in symbols)
# (36, 162, 163, 165, 8364, 164)

import array
array.array('I', (ord(symbol) for symbol in symbols))
# array('I', [36, 162, 163, 165, 8364, 164])
```

## 元组

元组除了可以用作不可变的列表，还可以用作没有字段名的记录（record）。

元组保存了记录：元组中的每个项都存放了记录中一个字段的数据，并且项的位置信息给数据赋予了意义。

`%` 格式化操作符可以理解元组，并将每个项作为单独的字段。

用 `for` 循环可以分开获取元组中的多个不同位置的项，称为拆包（unpacking），拆包时不需要的项可以赋值给 `_` 占位符。

任何可迭代对象都可以进行元组拆包。唯一的要求是可迭代对象为接收元组中的每个变量恰好生成一个项，除非使用 `*` 来捕获多余的项。可迭代对象拆包（iterable unpacking）的说法逐渐比元组拆包（tuple unpacking）更流行。

最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的项，一并赋值到由对应的变量组成的元组中。

```python
lax_coordinates = (33.9425, -118.408056)

# unpacking
latitude, longitude = lax_coordinates

latitude # 33.9425
longitude # -118.408056
```

通过元组拆包可以不使用中间变量交换两个变量的值：

```python
b, a = a, b
```

可以用 `*` 运算符把一个可迭代对象拆开作为函数的参数：

```python
div(20, 8) # (2, 4)

t = (20, 8)
quotient, remainder = divmod(*t)  # (2, 4)
```

元组拆包还可以让一个函数可以用元组的形式返回多个值。同样可以用 `_` 占位符忽略不感兴趣的值。

`*args` 用于获取不确定数量的参数。

```python
a, b, *rest = range(5)
a, b, rest  # (0, 1, [2, 3, 4])

a, b, *rest = range(3)
a, b, rest # (0, 1, [2])

a, b, *rest = range(2)
a, b, rest # (0, 1, [])
```

在平行赋值中，`*` 前缀只能用在一个变量前面，但可以出现在赋值表达式的任意位置：

```python
a, *body, c, d = range(5)
a, body, c ,d  # (0, [1, 2], 3, 4)

*head, b, c ,d = range(5)
head, b, c ,d  # ([0, 1], 2, 3, 4)
```

元组拆包可以用于嵌套结构中，只要这个接受元组的嵌套结构符合表达式本身的嵌套结构。

Python 3.5 扩展了 `*` 可迭代对象拆包操作符和 `**` 字典拆包操作符，见 [What's New In Python 3.5](https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations)。

要将元组作为记录来使用，还需要能够给记录中的字段命名，可以通过 `namedtuple` 工厂函数来实现。

### 元组作为不可变的列表

`tuple` 类可以看作 `list` 类的一个不可变变体（immutable variant）。

Python 解释器和标准库将元组的使用扩大化，作为不可变的列表来使用。这带来两个好处：

- 清晰：每当看到代码中的 `tuple`，应该知道它的长度不会再改变；
- 性能：`tuple` 比相同长度的 `list` 使用的内存更少，而且还能让 Python 做一些优化。

但是 `tuple` 的不可变的能力仅应用与它所包含的引用。元组中的引用无法删除或取代。但是如果引用指向一个可变对象（如 `list`），并且该对象做出改变，则 `tuple` 的值也会改变。

```python
a = (10, 'alpha', [1, 2])
b = (10, 'alpha', [1, 2])

a == b  # True

b[-1].append(99)
a == b  # False

b  # (10, 'alpha', [1, 2, 99])
```

具有可变项的元组中的可变值可能导致 bug。如果确定 `tuple` 不会改变，则可以计算它的散列值。一个对象仅在值永远无法改变时是可散列的。可以通过 `hash` 函数来检查元组（或任何对象）是否拥有一个固定的值。

元组比列表效率更高的原因：为了对元组字面量求值，Python 编译器对一个运算的元组常量生成字节码。但对于列表字面量而言，生成的字节码将每个元素作为单独的常量推入数据栈中，然后再构建列表。

对于可散列的元组 `t`，`tuple(t)` 构造函数仅返回指向同一个 `t` 的引用，无需拷贝，因为如果 `t` 是可散列的，它的值就是固定的。相反地，对于列表 `l`，`list(l)` 构造函数必须创建一个 `l` 的新拷贝。

因为长度固定，`tuple` 的实例分配恰好所需的内存。`list` 的实例则分配到更稀疏的空间，来均摊以后进行列表递增操作的开销。

元组中指向项的引用存储在元组结构自身的一个数组中。而列表保存的指向引用的数组则存储在其他地方。添加的间接会导致 CPU 缓存低效，对性能有潜在影响。但这个间接是必需的，因为当列表增长到超过当前所分配的空间大小时，引用的数组需要重分配来获得空间。

除了添加和移除项的方法，以及 `__reversed__` 方法外，元组支持列表的所有方法。但 `__reversed__` 方法不过是为了优化，`reversed(my_tuple)` 仍然能用。

## 切片

Python 中所有序列类型都支持切片操作。

在基于 0 的索引中，切片和区间忽略最后一个元素的好处：

- 当只有最后一个位置信息时，我们也可以快速看出切片和区间里有几个元素：`range(3)` 和 `my_list[:3]` 都返回 3 个元素。
- 当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标 `(stop - start)` 即可。
- 这样做也让我们可以利用任意一个下标 `x` 把序列分割成不重叠的两部分，只要写成 `my_list[:x]` 和 `my_list[x:]` 就可以了。

可以用 `s[a:b:c]` 的形式对 `s` 在 `a` 和 `b` 之间以 `c` 为间隔取值。`c` 的值还可以为负，负值意味着反向取值。

```python
s = 'bicycle'
s[::3]   # 'bye'
s[::-1]  # 'elcycib'
s[::-2]  # 'eccb'
```

`a:b:c` 这种用法只能作为索引或者下标运算符用在 `[]` 中来返回一个切片对象：`slice(a, b, c)`。

对 `seq[start:stop:step]` 进行求值的时候，Python 会调用 `seq.__getitem__(slice(start, stop, step))`。

通过切片对象可以给切片命名，就像电子表格软件里给单元格区域取名字一样。

### 多维切片和省略

`[]` 运算符里还可以使用以逗号分开的多个索引或者是切片。`__getitem__` 和 `__setitem__` 特殊方法处理 `[]` 运算符，接收 `a[i, j]` 中的索引作为元组。换句话说，要对 `a[i, j]` 求值，Python 会调用 `a.__getitem__((i, j))`。

NumPy 库中二维 `numpy.ndarray` 的项就用 `a[i, j]` 这种形式来获取，二维切片用 `a[m:n, k:l]` 这样的表达式来获取。

Python 内置的序列类型除了 `memoryview` 都是一维的，因此它们只支持单一的索引或切片，成对出现的索引是没有用的。

省略（ellipsis）符的正确书写方法是三个英语句号（...），而不是 Unicdoe 码位 U+2026 表示的半个省略号（…）。省略符在 Python 的 parser 看来是一个 token，而实际上它是 `Ellipsis` 对象的别名，而 `Ellipsis` 对象又是 `ellipsis` 类的单一实例。

省略符可以作为参数传递给函数，如 `f(a, ..., z)`；可以作为切片规范的一部分，如 `a[i:...]`。

NumPy 使用省略符作为多维数组切片的快捷方式，如 `x` 是四维数组，则 `x[i, ...]` 是 `x[i, :, :, :]` 的缩写。

除了用来提取序列里的内容，切片还可以用来就地修改可变序列，也就是说修改的时候不需要重新组建序列。

### 切片赋值

如果把切片放在赋值语句的左边，或把它作为 `del` 语句的目标，我们就可以对可变序列进行嫁接、切除或就地修改操作。

```python
l = list(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20, 30]    # [0, 1, 20, 30, 5, 6, 7, 8, 9]
del l[5:7]           # [0, 1, 20, 30, 5, 8, 9]
l[3::2] = [11, 22]   # [0, 1, 20, 11, 5, 22, 9]
l[2:5] = 100         # TypeError: can only assign an iterable
l[2:5] = [100]       # [0, 1, 100, 22, 9]
```

如果赋值的目标是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

## `+` 和 `*` 运算符

一般默认序列会支持 `+` 和 `*` 运算符。通常 `+` 号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python 会新建一个包含同样类型数据的序列来作为拼接的结果。

可以使用 `*` 与一个整数相乘，来多次拼接相同的序列拷贝。注意若序列中的元素是可变对象的引用，如 `my_list = [[]] * 3` 得到的列表，列表中的 3 个元素其实是 3 个引用，并且这 3 个引用指向同一个列表。这可能不是想要的结果。

`+` 和 `*` 永远会创建一个新的对象，而不会修改它们的运算数。

最好用列表推导来初始化嵌套列表。

## 序列的增量赋值

增量赋值运算符 `+=` 和 `*=` 的表现取决于它们的第一个运算对象。

`+=` 背后的特殊方法是 `__iadd__`，用于「就地加法」。但是如果一个类没有实现这个方法的话，Python 会回退调用 `__add__`。

对于 `a += b` 这个表达式，如果 `a` 实现了 `__iadd__`，就调用该方法。如果是可变序列（如 `list`、`bytearray`、`array.array`），`a` 会就地修改（效果类似于 `a.extend(b)`）。如果 `a` 没有实现 `__iadd__`，表达式 `a += b` 就和 `a = a + b` 效果相同。先对表达式 `a + b` 求值，产生一个新的对象，然后将新的对象绑定到 `a` 上。绑定到 `a` 的对象的 ID 可能改变也可能不变，取决于 `__iadd__` 方法是否可用。

对于可变序列，可以认为都实现了 `__iadd__` 方法，`+=` 运算是就地加法。对于不可变序列，显然不可能发生就地修改。

同理 `*=` 运算通过 `__imul__` 方法实现，运算原则和 `+=` 相同。

对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。`str` 是一个例外，因为对字符串做 `+=` 实在是太普遍了，所以 CPython 对它做了优化。为 `str` 初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作。

```python
t = (1, 2, [30, 40])
t[2] += [50, 60]
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: 'tuple' object does not support item assignment

t  # (1, 2, [30, 40, 50, 60])
```

对元组的元素赋值，导致抛出了异常，并且同时修改了元组的元素。

查看表达式 `s[a]+=b` 的字节码，假设 `s` 是一个元组，`s[a]` 是一个列表。先将 `s[a]` 的值存放到 TOS（Top Of Stack，栈的顶端）。然后计算 `TOS += b`，这一步成功了，因为 `TOS` 指向一个可变对象。最后进行 `s[a] = TOS` 赋值。最后一步失败，因为 `s` 是不可变的元组。

如果写成 `t[2].extend([50, 60])` 则可以避免这个异常。

通过上例得到的教训：

- 不要把可变对象放在元组里面。
- 增量赋值不是一个原子操作。
- 查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

## `list.sort` 方法和内置函数 `sorted`

`list.sort` 方法会就地排序列表，返回值是 `None` 来提醒它改变了接收者（接收者指方法调用的目标，就是在方法体中绑定到 `self` 的对象），且不会创建一个新的列表。

在这种情况下返回 `None` 其实是 Python 的一个惯例：如果一个函数或者方法就地修改了对象，那它就应该返回 `None`，好让调用者知道接收者发生了变动，而且并未产生新的对象。

内置函数 `sorted` 会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。

二者都有两个可选的仅限关键字参数：

- `reverse`：如果为 `True`，将序列降序输出；默认为 `False`。
- `key`：一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。比如说，在对一些字符串排序时，可以用 `key=str.lower` 来实现忽略大小写的排序，或者是用 `key=len` 进行基于字符串长度的排序。默认是恒等函数（identity function，通过比较项自身的值来排序）。

Python 默认按照字符码的字典序来排序字符串。因此 ASCII 大写字母排在小写字母前面，非 ASCII 字符可能排序结果不够合理。

Python 的排序算法 Timsort 是稳定的。稳定指对于比不出大小的两个元素，每次排序结果中它们的相对位置不会发生改变。即使将排序结果完全翻转，也不会改变。

## 用 `bisect` 来管理已排序的序列

可以对已排序的序列进行高效地搜索，而标准库的 `bisect` 模块给我们提供了二分查找算法。

`bisect` 模块包含两个主要函数，`bisect` 和 `insort`，两个函数都利用二分查找算法来在有序序列中查找或插入元素。

`bisect(haystack, needle)` 在 `haystack`（干草垛，必须是有序序列）里搜索 `needle`（针）的位置，该位置满足的条件是，把 `needle` 插入这个位置之后，`haystack` 还能保持升序。

`bisect` 可以通过两个可选参数 `lo` 和 `hi` 来缩小在序列中搜索的范围。`lo` 的默认值是 `0`，`hi` 的默认值是序列的 `len()`。

`bisect` 函数其实是 `bisect_right` 函数的别名。另外有一个 `bisect_left` 函数。区别在于当 needle 与列表中相比较的项相等时，`bisect_right` 返回已存在项后面的插入点，而 `bisect_left` 返回已存在项的位置，从而在该项前面插入。对于 `int` 这样的简单类型来说，插入的先后顺序没有什么区别，但是如果序列包含的对象虽然不同但比较是相等的，就有关系了。如 `1` 和 `1.0` 是不同的，但 `1 == 1.0` 返回 `True`。

`bisect` 可以通过数值索引来查询表。

`insort(seq, item)` 把变量 `item` 插入到序列 `seq` 中，并能保持 `seq` 的升序顺序。

`insort` 跟 `bisect` 一样，有 `lo` 和 `hi` 两个可选参数用来控制查找的范围。它也有个变体叫 `insort_left`，这个变体在背后用的是 `bisect_left`。

## 当列表不是首选时

如果要处理数字的列表，数组会更好。

如果需要不断地在一端添加项，另一端删除项，则使用 `deque`。

如果需要不断检查集合类型中是否存在一个项，可以为集合类型使用 `set`，特别是集合类型中有大量的项的时候。`set` 对快速的成员检查做了优化。但这些集合类型不是序列，它们的内容是无序的。

### 数组

如果我们需要一个只包含数字的列表，那么 `array.array` 比 `list` 更高效。比如存储浮点数时，`array` 能节省大量内存。数组支持所有跟可变序列有关的操作，包括 `.pop`、`.insert` 和 `.extend`。另外，数组还提供快速从文件读取和存入文件的方法，如 `.frombytes` 和 `.tofile`。

Python 的数组和 C 的数组一样简练。一个 `float` 的 `array` 不包含全部的 `float` 实例，仅有包裹起来的字节，用来表示它们的机器值，类似于 C 中 `double` 的数组。创建数组需要一个类型码（typecode），是一个字母，用来决定存放数组每个项的底层 C 类型。例如 `b` 是 `signed char` 的类型码，创建一个 `array('b')`，则每个项会存储到单个字节中，并解释为从 -128 到 127 的整数。对于数字的较大序列，可以节省大量内存。Python 不会允许将类型不匹配的数字存放到指定数组中。

`array.fromfile` 从二进制文件中读取数字比文本文件要快，因为后者会使用内置的 `float` 方法将每行文字转换成浮点数。另外 `array.tofile` 写入到二进制文件也比写入到文本文件要快，而且更省空间。

另一个快速保存数值数据的方式是用于对象序列化的 `pickle` 模块。

对于表示二进制数据的数值数组，如光栅图片，有 `bytes` 和 `bytearray` 类型。

直到 Python 3.8，`array` 类型没有类似于 `list.sort()` 的就地排序方法。如果需要对数组排序，使用 `sorted` 函数新建一个数组：`a = array.array(a.typecode, sorted(a))`。

在给有序数组添加项时，为了保持有序，使用 `bisect.insort` 函数。

### 内存视图

`memoryview` 内置类是一个共享内存的序列类型，能让用户在不复制内容字节的情况下操作同一个数组的不同切片。

`memoryview.cast` 方法的概念跟 `array` 模块类似，能用不同的方式以单元的形式读写多个字节，而且内容比特不会随意移动。`memoryview.cast` 返回另一个 `memoryview` 对象，这些对象会一直共享同一块内存。

Python 3.5 添加了一个特性，可以使用元组来索引 `memoryview`。

### 双向队列和其他的队列

`collections.deque` 类（双向队列）是一个线程安全的、可以快速从两端添加或者删除元素的双端队列。

如果想要保存「最近所见的项」，可以使用双端队列，因为 `deque` 是有界的，即能够以固定的最大长度创建，当达到最大长度时添加新的项，它会从相反的方向丢弃项。

其他的队列：

- `queue`
- `multiprocessing`
- `asyncio`
- `heapq`

---

推荐参考书目：

- Python Cookbook 3rd 第一章
- Python Cookbook 2nd 第五章和第六章