---
title: "Fluent Python Chap18：上下文管理器"
date: 2021-06-05T13:08:07+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

`else` 子句不仅能在 `if` 语句中使用，还能在 `for`、`while` 和 `try` 语句中使用。

- `for`：仅当 `for` 循环运行完毕时（即 `for` 循环没有被 `break` 语句中止）才运行 `else` 块。
- `while`：仅当 `while` 循环因为条件为假值而退出时（即 `while` 循环没有被 `break` 语句中止）才运行 `else` 块。
- `try`：仅当 `try` 块中没有异常抛出时才运行 `else` 块。`else` 子句抛出的异常不会由前面的 `except` 子句处理。

在所有情况下，如果异常或者 `return`、`break` 或 `continue` 语句导致控制权跳到了复合语句的主块之外，`else` 子句也会被跳过。

可以把除了 `if` 语句外的 `else` 当作 `then`。

在 Python 中，`try/except` 不仅用于处理错误，还常用于控制流程。

- EAFP 风格：先假定存在有效的键或属性，如果假定不成立，那
  么捕获异常。这种风格简单明快，特点是代码中有很多 `try` 和 `except` 语句。
- LBYL 风格：这种编程风格在调用函数或查找属性或键之前显式测试前提条件。与 EAFP 风格相反，这种风格的特点是代码中有很多 `if` 语句。

---

`with` 语句会设置一个临时的上下文，交给上下文管理器对象控制，并且负责清理上下文。这么做能避免错误并减少样板代码，因此 API 更安全，而且更易于使用。

上下文管理器对象存在的目的是管理 `with` 语句，就像迭代器的存在是为了管理 `for` 语句一样。

`with` 语句的目的是简化 `try/finally` 模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、`return` 语句或 `sys.exit()` 调用而中止，也会执行指定的操作。`finally` 子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。

上下文管理器协议包含 `__enter__` 和 `__exit__` 两个方法。`with` 语句开始运行时，会在上下文管理器对象上调用 `__enter__` 方法。`with` 语句运行结束后，会在上下文管理器对象上调用 `__exit__` 方法，以此扮演 `finally` 子句的角色。

`with` 语句最常见的例子是确保关闭文件对象。

执行 `with` 后面的表达式得到的结果是上下文管理器对象，不过，把值绑定到目标变量上（`as` 子句）是在上下文管理器对象上调用 `__enter__` 方法的结果。

与函数和模块不同，`with` 块没有定义新的作用域。

`__enter__` 方法除了返回上下文管理器之外，还可能返回其他对象。

不管控制流程以哪种方式退出 `with` 块，都会在上下文管理器对象上调用 `__exit__` 方法，而不是在 `__enter__` 方法返回的对象上调用。

解释器调用 `__enter__` 方法时，除了隐式的 `self` 之外，不会传入任何参数。传给 `__exit__` 方法的三个参数：

- `exc_type`：异常类（例如 `ZeroDivisionError`）。
- `exc_value`：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用 `exc_value.args` 获取。
- `traceback`：`traceback` 对象。

---

`contextlib` 模块中的 `@contextmanager` 装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 `__enter__` 和 `__exit__` 方法，而只需实现有一个 `yield` 语句的生成器，生成想让 `__enter__` 方法返回的值。

在使用 `@contextmanager` 装饰的生成器中，`yield` 语句的作用是把函数的定义体分成两部分：`yield` 语句前面的所有代码在 `with` 块开始时（即解释器调用 `__enter__` 方法时）执行，`yield` 语句后面的代码在 `with` 块结束时（即调用 `__exit__` 方法时）执行。
