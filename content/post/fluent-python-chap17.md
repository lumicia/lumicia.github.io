---
title: "Fluent Python Chap17：迭代"
date: 2021-06-05T08:59:54+08:00
categories: ["Python"]
tags: ["Fluent PYthon"]
draft: false
---

迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式（Iterator pattern）。

Python 没有宏，因此为了抽象出迭代器模式，需要改动语言本身。`yield` 关键字用于构建生成器（generator），其作用与迭代器一样。

Python 中所有生成器都是迭代器，因为生成器完全实现了迭代器接口。一般而言，迭代器用于从集合中取出元素；而生成器用于「凭空」生成元素。在 Python 中，二者可视为同一概念。

<!--more-->

现在内置的 `range()` 函数返回一个类似生成器的对象，而以前则返回完整的列表。如果想返回列表，需要明确指明，如 `list(range(100))`。

在 Python 中，所有集合都可以迭代。在 Python 语言内部，迭代器用于支持：

- `for` 循环；
- 构建和扩展集合类型；
- 逐行遍历文本文件；
- 列表推导、字典推导和集合推导；
- 元组拆包；
- 调用函数时，使用 `*` 拆包实参。

解释器需要迭代对象 `x` 时，会自动调用 `iter(x)`。内置的 iter 函数有以下作用：

1. 检查对象是否实现了 `__iter__` 方法，如果实现了就调用它，获取一个迭代器。
2. 如果没有实现 `__iter__` 方法，但是实现了 `__getitem__` 方法，Python 会创建一个迭代器，尝试按顺序（从索引 `0` 开始）获取元素。
3. 如果尝试失败，Python 抛出 `TypeError` 异常，通常会提示 `C object is not iterable`（`C` 对象不可迭代），其中 `C` 是目标对象所属的类。

任何 Python 序列都可迭代的原因是，它们都实现了 `__getitem__` 方法。其实，标准的序列也都实现了 `__iter__` 方法，因此你也应该这么做。

这是鸭子类型（duck typing）的极端形式：不仅要实现特殊的 `__iter__` 方
法，还要实现 `__getitem__` 方法，而且 `__getitem__` 方法的参数是从 `0` 开始的整数（`int`），这样才认为对象是可迭代的。

在白鹅类型（goose-typing）理论中，可迭代对象的定义简单一些，不过没那么灵活：如果实现了 `__iter__` 方法，那么就认为对象是可迭代的。此时，不需要创建子类，也不用注册，因为 `abc.Iterable` 类实现了 `__subclasshook__` 方法。

---

**可迭代的对象**：使用 `iter` 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 `__iter__` 方法，那么对象就是可迭代的。序列都可以迭代；实现了 `__getitem__` 方法，而且其参数是从零开始的索引，这种对象也可以迭代。

可迭代的对象和迭代器之间的关系：Python 从可迭代的对象中获取迭代器。

`StopIteration` 异常表明迭代器到头了。Python 语言内部会处理 `for` 循环和其他迭代上下文（如列表推导、元组拆包，等等）中的 `StopIteration` 异常。

标准的迭代器接口有两个方法：

- `__next__`：返回下一个可用的元素，如果没有元素了，抛出 `StopIteration` 异常。
- `__iter__`：返回 `self`，以便在应该使用可迭代对象的地方使用迭代器，例如在 `for` 循环中。

迭代器接口在 `collections.abc.Iterator` 抽象基类中制定。这个类定义了 `__next__` 抽象方法，而且继承自 `Iterable` 类；`__iter__` 抽象方法则在 `Iterable` 类中定义。

`Iterator` 抽象基类实现 `__iter__` 方法的方式是返回实例本身（`return self`）。这样，在需要可迭代对象的地方可以使用迭代器。

`Iterator` 抽象基类定义的抽象方法是 `it.__next__()`，应该避免直接调用特殊方法，使用 `next(it)` 即可。

`abc.Iterator` 抽象基类中 `__subclasshook__` 方法的作用：检查对象 `x` 是否为迭代器最好的方式是调用 `isinstance(x, abc.Iterator)`，即使对象 `x` 所属的类不是 `Iterator` 类的真实子类或虚拟子类，也能这样检查。

因为迭代器只需 `__next__` 和 `__iter__` 两个方法，所以除了调用 `next()` 方法，以及捕获 `StopIteration` 异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法「还原」迭代器。如果想再次迭代，那就要调用 ` iter(...)`，传入之前构建迭代器的可迭代对象。传入迭代器本身没用，因为前面说过 `Iterator.__iter__` 方法的实现方式是返回实例本身，所以传入迭代器无法还原已经耗尽的迭代器。

**迭代器**：迭代器是这样的对象，实现了无参数的 `__next__` 方法，返回序列中的下一个元素；如果没有元素了，那么抛出 `StopIteration` 异常。Python 中的迭代器还实现了 `__iter__` 方法，因此迭代器也可以迭代。

---

迭代器应该实现 `__next__` 和 `__iter__` 两个方法，让迭代器通过 `issubclass(SomeIterator, abc.Iterator)` 测试。如果让 `SomeIterator` 类继承 `abc.Iterator` 类，那么它会继承 `abc.Iterator.__iter__` 这个具体方法。

构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。要知道，可迭代的对象有个 `__iter__` 方法，每次都实例化一个新的迭代器；而迭代器要实现 `__next__` 方法，返回单个元素，此外还要实现 `__iter__` 方法，返回迭代器本身。

因此，迭代器可以迭代，但是可迭代的对象不是迭代器。

不要在可迭代对象类中实现 `__next__` 方法，让类实例既是可迭代对象，又是自身的迭代器。

迭代器模式的用途：

- 访问一个聚合对象的内容而无需暴露它的内部表示；
- 支持对聚合对象的多种遍历；
- 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。

为了支持多种遍历，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用 `iter(my_iterable)` 都新建一个独立的迭代器。因此，在可迭代对象类之外再定义一个迭代器的类。

可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现 `__iter__` 方法，但不能实现 `__next__` 方法。另一方面，迭代器应该一直可以迭代。迭代器的 `__iter__` 方法应该返回自身。

---

在 Python 中可以用生成器代替迭代器模式中定义的迭代器类。

在迭代器模式中，可迭代对象类的 `__iter__` 方法调用迭代器类的构造方法创建一个迭代器并将其返回。而使用生成器后，迭代器其实是生成器对象，每次调用 `__iter__` 方法都会自动创建一个实现了迭代器接口的生成器对象，因为这里的 `__iter__` 方法是生成器函数。

生成器函数的工作原理：只要 Python 函数的定义体中有 `yield` 关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。

生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给 `next(...)` 函数时，生成器函数会向前，执行函数定义体中的下一个 yield 语句，返回产出的值，并在函数定义体的当前位置暂停。最终，函数的定义体返回时，外层的生成器对象会抛出 `StopIteration` 异常——这一点与迭代器协议一致。

---

简单的生成器函数可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。

生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。

如果函数或构造方法只有一个参数，传入生成器表达式时不用写一对调用函数的括号，再写一对括号围住生成器表达式，只写一对括号就行了。然而，如果生成器表达式后面还有其他参数，那么必须使用括号围住，否则会抛出 `SyntaxError` 异常。

---

生成器也可用于生成不受数据源限制的值。

典型的迭代器模式作用很简单——遍历数据结构。不过，即便不是从集合中获取元素，而是获取序列中即时生成的下一个值时，也用得到这种基于方法的标准接口。例如，内置的 `range` 函数用于生成有穷整数等差数列（Arithmetic Progression，AP），`itertools.count` 函数用于生成无穷等差数列。

---

如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的 `for` 循环。现在可以用 `yield from` 代替内层的 `for` 循环。

除了代替循环之外，`yield from` 还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端代码提供的值。

内置的 `sorted` 函数接受一个可迭代的对象，返回不同的值，值是真正的列表而非生成器。它可以处理任意的可迭代对象。

在 Python 中迭代对象 `x` 时会调用 `iter(x)`。不过，`iter` 函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出 `StopIteration` 异常，而不产出哨符。

---

生成器对象有一个 `.send()` 方法。与 `.__next__()` 方 法 一 样，`.send()` 方法使生成器前进到下一个 `yield` 语句。 不过，`.send()` 方法还允许使用生成器的客户把数据发给自己，即不管传给 `.send()` 方法什么参数，那个参数都会成为生成器函数定义体中对应的 `yield` 表达式的值。也就是说，`.send()` 方法允许在客户代码和生成器之间双向交换数据。而 `.__next__()` 方法只允许客户从生成器中获取数据。像这样使用的话，生成器就变身为协程。
