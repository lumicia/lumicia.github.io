---
title: "Fluent Python Chap13：接口"
date: 2021-06-04T08:52:17+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

抽象基类的常见用途：实现接口时作为超类使用。

Python 语言没有 `interface` 关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如 `__getitem__` 或 `__add__`。

按照定义，受保护的属性和私有属性不在接口中：即便「受保护的」属性也只是采用命名约定实现的（单个前导下划线）；私有属性可以轻松地访问，原因也是如此。

另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用 `obj.attr` 句法的客户代码不会受到影响。

<!--more-->

关于接口有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。Python 文档中的「文件类对象」或「可迭代对象」就是这个意思。接口是实现特定角色的方法集合，这样理解正是 Smalltalk 程序员所说的协议。协议与继承没有关系。一个类可能会实现多个接口，从而让实例扮演多个角色。

协议是接口，但不是正式的（只由文档和约定定义），因此协议不能像正式接口那样施加限制。一个类可能只实现部分接口，这是允许的。

Python 数据模型的哲学是尽量支持基本协议。

`Sequence` 具有的方法和属性：

- *`__getitem__`*
- `__contains__`
- `__iter__`
- `__reversed__`
- `index`
- `count`

`Sequence` 抽象基类继承 `Container` 的 *`__contains__`*、`Iterable` 的 *`__iter__`* 和 `Sized` 的 *`__len__`* 抽象方法。

鉴于序列协议的重要性，如果没有 `__iter__` 和 `__contains__` 方法，Python 会调用 `__getitem__` 方法，设法让迭代和 `in` 运算符可用。

可变的序列必须提供 `__setitem__` 方法，可以在运行时通过 Monkey Patch 来把不可变序列变成可变的。Monkey Patch：在运行时修改类或模块，而不改动源码。

白鹅类型：只要 `cls` 是抽象基类，即 `cls` 的元类是 `abc.ABCMeta`，就可以使用 `isinstance(obj, cls)`。

继承抽象基类很简单，只需要实现所需的方法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。

此外，使用 `isinstance` 和 `issubclass` 测试抽象基类更为人接受。过去，这两个函数用来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事后还可以注册，让显式类型检查通过。

然而，即便是抽象基类，也不能滥用 `isinstance` 检查，用得多了可能导致代码异味，即表明面向对象设计得不好。在一连串 `if/elif/elif` 中使用 `isinstance` 做检查，然后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用 `if/elif/elif` 块硬编码分派逻辑。

另一方面，如果必须强制执行 API 契约，通常可以使用 `isinstance` 检查抽象基类。

例如，使用序列时把它当成列表处理。不用检查参数的类型是不是 `list`，而是直接接受参数，立即使用它构建一个列表。这样，就可以接受任何可迭代对象，如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。当然，如果序列太长或者需要就地修改序列而导致无法复制参数，就不能采用这种方式；此时，使用 `isinstance(x, abc.MutableSequence)` 更好。

使用鸭子类型处理单个字符串或由字符串组成的可迭代对象。

Python 在导入时不会检查抽象方法的实现，在运行时实例化一个类时才会真正检查。因此，如果没有正确实现某个抽象方法，Python 会抛出 `TypeError` 异常，并在错误信息中提示无法实例化抽象类的抽象方法。所以抽象基类的子类即使不需要一些抽象方法提供的行为，也要为抽象基类来实现它们。

---

Python 3.9 在 `collections.abc` 中定义了 [25 个抽象基类](https://docs.
python.org/3/library/collections.abc.html#collections-abstract-base-classes)。

`numbers`[包](https://docs.python.org/3/library/numbers.html) 定义了线性层次结构的数字塔。

声明抽象基类最简单的方式是继承 `abc.ABC` 或其他抽象基类。在函数上堆叠装饰器时，`@abstractmethod ` 装饰器应放到最里层。

---

白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类定义的接口，而 Python 会相信我们，从而不做检查。

注册虚拟子类的方式是在抽象基类上调用 `register` 方法。这么做之后，注册的类会变成抽象基类的虚拟子类，而且 `issubclass` 和 `isinstance` 等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。

`register` 方法通常作为普通的函数调用，注册其他地方定义的类，不过也可以作为装饰器使用。

类的继承关系在一个特殊的类属性 `__mro__`（Method Resolution Order）中指定。这个属性的作用很简单，按顺序列出类及其超类，Python 会按照这个顺序搜索方法。

即便不注册，抽象基类也能把一个类识别为虚拟子类。只要抽象基类实现了特殊的类方法 `__subclasshook__`，就可以通过 `issubclass` 函数来判断。
