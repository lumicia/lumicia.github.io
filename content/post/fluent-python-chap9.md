---
title: "Fluent Python Chap9：函数装饰器和闭包"
date: 2021-05-14T09:46:08+08:00
categories: ["Python"]
tags: ["Fluent Python"]
draft: false
---

函数装饰器用于在源码中「标记」函数，以某种方式增强函数的行为。掌握装饰器必须先理解闭包。

除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。

<!--more-->

## 装饰器基础知识

装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。

假如有个名为 `decorate` 的装饰器：

```python
@decorate
def target():
    print('running target()')
```

上述代码的效果与下述写法一样：

```python
def target():
    print('running target()')

target = decorate(target)
```

两种写法的最终结果一样：上述两个代码片段执行完毕后得到的 `target` 不一定是原来那个 `target` 函数，而是 `decorate(target)` 返回的函数。

装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。

综上，装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行。

## Python 何时执行装饰器

装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时（即 Python 加载模块时）。

函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了 Python 程序员所说的导入时和运行时之间的区别。

实际上，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上；大多数装饰器会在内部定义一个函数，然后将其返回。

## 使用装饰器改进「策略」模式

多数装饰器会修改被装饰的函数。通常，它们会定义一个内部函数，然后将其返回，替换被装饰的函数。使用内部函数的代码几乎都要靠闭包才能正确运作。为了理解闭包，我们要退后一步，先了解 Python 中的变量作用域。

## 变量作用域规则

Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。

如果在函数中赋值时想让解释器把函数中声明的变量当成全局变量，要使用 `global` 声明。

## 闭包

闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。

自由变量指未在本地作用域中绑定的变量。

Python 在 `__code__` 属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称。

自由变量的绑定在 `__closure__` 属性中。`__closure__` 中的各个元素对应于 `__code__.co_freevars` 中的一个名称。这些元素是 `cell` 对象，有个 `cell_contents` 属性，保存真正的值。

综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。

## nonlocal 声明

Python 3 引入了 `nonlocal` 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 `nonlocal` 声明的变量赋予新值，闭包中保存的绑定会更新。

## 标准库中的装饰器

Python 内置了三个用于装饰方法的函数：`property`、`classmethod` 和 `staticmethod`。

另一个常见的装饰器是 `functools.wraps`，它的作用是协助构建行为良好的装饰器。

标准库中最值得关注的两个装饰器是 `lru_cache` 和全新的 `singledispatch`（Python 3.4 新增）。这两个装饰器都在 `functools` 模块中定义。

## 叠放装饰器

把 `@d1` 和 `@d2` 两个装饰器按顺序应用到 `f` 函数上，作用相当于 `f = d1(d2(f))`。

```python
@d1
@d2
def f():
    print('f')
```

等同于：

```python
def f():
    print('f')

f = d1(d2(f))
```

## 参数化装饰器

让装饰器接受其他参数的方法：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。