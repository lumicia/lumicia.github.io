---
title: "Ostep Chap2 05：比例份额调度"
date: 2021-09-13T19:49:01+08:00
categories: ["OS"]
tags: ["OSTEP"]
draft: false
---

比例份额（proportional-share）调度器也称为公平份额（fair-share）调度器。它并不对周转时间或响应时间进行优化，而是确保每个任务都能获得某个百分比的 CPU 时间。

实现比例份额调度器的关键是如何按比例来分配 CPU。比例份额调度的一个例子是彩票调度（lottery scheduling）。彩票调度的基本思想是每隔一段时间，用一张彩票来决定接下来轮到哪个进程运行；需要运行更长时间的进程应该给予更多机会中奖。

彩票调度用彩票（ticket）来代表进程应该得到的资源份额。使用随机（randomness）来决定中奖号码。随机的三个优点：

1. 避免奇怪的边界情况；
2. 轻量；
3. 非常快。

彩票调度还提供了一系列机制来操控彩票的行为。

- 彩票货币（ticket currency）。用户可以将拥有的一组彩票以不同货币面值的形式分配到用户自己的任务中；系统之后会自动将上述货币转换成全局的正确比例。
- 彩票转让（ticket transfer）。进程可以将它的彩票转让给其他进程。这在客户端 / 服务器交互中非常有用。
- 彩票通胀（ticket inflation）。进程可以临时提升或降低它拥有的彩票数。在进程之间互相信任的情况下有用，可以让需要更多 CPU 时间的进程直接将需求反映给系统，而无需与其他进程通信。

彩票调度的实现非常简单，只需要：

- 一个优秀的随机数生成器；
- 一个追踪系统中进程的数据结构；
- 彩票的总票数。

彩票调度的问题：

- 如何为任务分配彩票数。
- 份额是非确定性的。

彩票调度的第一个问题仍未解决。第二个问题则是通过步长调度（stride scheduling）来解决。

在步长调度中，系统中的每个任务都有一个步长，与它拥有的彩票数成反比。使用一个较大的数字除以赋予进程的彩票数得到进程的步长。进程每次运行的时候，将一个计数器按它的步长递增（称为行程值，pass value）来追踪它的全局进度。行程值较小的进程优先运行。一段时间内步长调度中各个进程运行次数和彩票数的比例是一样的。

步长调度的问题在于需要全局状态，无法为新加入的进程合理设置步长。

彩票调度和步长调度还有一个共同问题是无法很好地处理 I/O。

## Linux 完全公平调度器（CFS)

Linux 的完全公平调度器（Completely Fair Scheduler，CFS）以不同的形式实现了公平份额调度。

为了实现高效率，CFS 花费极少的时间做出调度决策。

为了在所有竞争的进程之间公平分配 CPU，CFS 使用一种简单的基于计数的技术，称为虚运行时（virtual runtime，`vruntime`）。

每当一个进程运行的时候，它累加 `vruntim`。一般情况下，每个进程的 `vruntime` 以相同比例递增，与物理时间成比例。当发生调度时，CFS 选择具有最小 `vruntime` 的进程接着运行。

一个问题是 CFS 是如何知道何时进行切换的。矛盾在于：如果 CFS 频繁切换，增加了公平，因为 CFS 会确保每个进程都会在一个极小的时间窗口得到它的 CPU 份额，但付出性能代价（过多的上下文切换）；如果 CFS 很少切换，增加了性能（减少了上下文切换），但付出了近期公平的代价。

CFS 通过多种控制参数来处理这个矛盾：

- `sched_latency`：CFS 用该值来决定切换前一个进程应该运行多久。一个经典的值是 48 毫秒。CFS 用该值除以进程数来决定进程的时间片。
- `min_granularity`：如果有非常多的进程，那么时间片会变得非常小，此时用该值来设置最小的时间片。通常设为 6 毫秒。

CFS 通过进程的 nice 级别来控制进程的优先级。每个进程的 nice 级别从 - 20 到 + 19，默认为 0。正的 nice 级别表示低优先级，负的 nice 级别表示高优先级。CFS 将每个进程的 nice 值映射到 `weight`。

一个进程的时间片等于：
$$
\text{time\_slice}_k = \frac{\text{weight}_k}{\sum^{n - 1}_{i = 0}\text{weight}_i} \cdot \text{sched\_latency}
$$
进程的虚运行时：
$$
\text{vruntime}_i = \text{vruntime}_i + \frac{\text{weight}_0}{\text{weight}_i} \cdot \text{runtime}_i
$$
$\text{weight}_0$ 默认为 1024。权重表的一个优点是当 nice 值的差是常数时，该表维持了 CPU 比例。

CFS 使用红黑树来查找接下来要运行的进程。CFS 将正在运行的（或可运行的）进程保存在红黑树中。如果进程处于等待 I/O 完成，或等待网络分组到达的睡眠状态，就从红黑树中移出，放在其他地方追踪。

取具有最小 `vruntime` 进程运行的一个问题在于从睡眠中醒来的进程具有比其他进程落后的 `vruntime`，因此会占据 `vruntime` 差值的 CPU 时间，直到追上其他进程。这个追赶的过程会导致其他进程饥饿。

CFS 解决这个问题的方法是修改任务醒过来时的 `vruntime`。特别地，CFS 将 `vruntime` 设置为在红黑树中找到的最小值。这种方法避免了饥饿，但代价是频繁进行短时间睡眠的任务一直不能获得公平份额的 CPU。
