---
title: "Ostep Chap2 03：调度基础"
date: 2021-09-10T20:43:49+08:00
categories: ["OS"]
tags: ["OSTEP"]
draft: false
---

上一节讲了进程运行的底层机制，这一节开始讲上层的策略。操作系统的调度器采取一系列的策略对进程的运行进行调度。

调度策略的三个重点：

- 关键的假设；
- 重要的度量；
- 基本的方法。

工作负荷假设：

1. 每个任务运行相同的时间。
2. 所有任务都在同一时间到达系统。
3. 每个任务在启动后都会完成。
4. 所有任务都只在 CPU 上运行（不执行 I/O）。
5. 每个任务的返回时间已知。

调度的一个度量：周转时间（turnaround time）。任务的周转时间定义为任务完成的时间减去任务到达系统的时间。周转时间是关于性能的度量。其他的还有关于公平（fairness）的度量。
$$
T_{turnaround} = T_{complete} - T_{arrival}
$$
一个基本的调度算法：先进先出（First in，First Out，FIFO），或称为先到先服务（First Come，First Served，FCFS）。

FIFO 的优点是非常简单，易于实现。缺点在于如果有某个任务不遵循第一个假设，并且运行时间非常长，那么其他任务需要等待它完成才能运行，导致平均的周转时间非常大。这种情况称为护送效应（convoy effect）。

为了改进 FIFO 的缺点，可以采取最短时间任务优先（Shortest Job First，SJF）的调度策略，优先运行最短时间的任务，然后是第二短的任务，以此类推。这种策略相较于 FIFO，可以减少平均的周转时间。在仅不满足第一个假设的情况下，SJF 是最优的调度算法。

如果任务不遵循第二个假设，那么在长时间任务先于短时间任务到达的情况下，即使采用 SJF 策略，也会导致和 FIFO 一样的问题。这是因为 SJF 是一个非抢占式（non-preemptive）调度器。

为了解决这个问题，需要让任务也不遵循第三个假设。调度器可以抢占（preempt）任务，让其他任务先运行，然后让被抢占的任务再运行。这种调度器称为最短时间完成优先（Shortest Time-to-Completion First，STCF) 或抢占式最短时间任务优先（Preemptive Shortest Job First，PSJF）调度器。任何时候有新的任务进入系统，STCF 调度器判断包含新任务在内的所有任务哪个需要最短的时间完成，就进行调度让它运行。在仅不满足前三个假设的情况下，STCF 是最优的调度算法。

用户使用计算机时，会期望计算机的响应越快越好，因此引入第二个度量：响应时间（response time）。响应时间定义为任务到达系统的时间到第一次被调度的时间。
$$
T_{response} = T_{firstrun} - T_{arrival}
$$
为了减少响应时间，引入了轮询（Round-Robin，RR）调度算法。轮询调度算法不会让任务一直运行到完成，而让任务在一个时间片（time slice）中运行，然后切换到下一个运行队列中的任务。重复这种运行加切换的模式，直到所有任务完成。时间片的长度必须是定时器中断的整数倍。

时间片越短，在响应时间度量下的 RR 算法性能越好。但太短的时间片也会让上下文切换的开销影响到整体的性能。因此，时间片需要足够长以均摊（amortize）切换的开销，并且让系统不会太久没有响应。

RR 算法的缺点是周转时间甚至比 FIFO 还差。更一般地讲，任何公平的策略都会导致像周转时间这样的度量不佳。

现在让任务不遵循第四个假设，因为所有的程序实际都会执行 I/O。当任务发出 I/O 请求，当前运行的任务不会使用 CPU，而是阻塞直到 I/O 完成。I/O 可能需要较长时间，此时调度器应该考虑调度其他任务在 CPU 上运行。

另外当 I/O 完成后，会发生中断，操作系统运行并将请求 I/O 的进程从阻塞状态转换到就绪状态。此时调度器需要决定运行哪个任务。可以采用重叠（overlap）的办法，让 CPU 在进程等待 I/O 时让其他进程使用 CPU，然后切换，重复这个过程直到任务完成，从而更好地利用处理器。

最后一个假设的处理方法是多级反馈队列（multi-level feedback queue），留在下一节讲解。
